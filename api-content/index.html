{"posts":[{"title":"js blob流和base64，以及file和base64的相互转换","content":"file和base64 1.file文件转换为base64，得到base64格式图片 var reader = new FileReader(); reader.readAsDataURL(this.files[0]); reader.onload = function(){ console.log(reader.result); //获取到base64格式图片 }; 2.base64转换为file function dataURLtoFile(dataurl, filename) {//将base64转换为文件 var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while(n--){ u8arr[n] = bstr.charCodeAt(n); } return new File([u8arr], filename, {type:mime}); } 测试案例： &lt;input type=&quot;file&quot; name=&quot;&quot; id=&quot;imgfile&quot;&gt; &lt;script&gt; var base64Img = ''; document.getElementById('imgfile').onchange = function(){ var fileReader = new FileReader(); fileReader.readAsDataURL(this.files[0]); fileReader.onload = function(){ base64Img = fileReader.result; console.log(dataURLtoFile(base64Img,'img11')) } } function dataURLtoFile(dataurl, filename) {//将base64转换为文件 var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while(n--){ u8arr[n] = bstr.charCodeAt(n); } return new File([u8arr], filename, {type:mime}); } &lt;/script&gt; blob和base64 3.base64转换为blob流 function dataURItoBlob(base64Data) { //console.log(base64Data);//data:image/png;base64, var byteString; if(base64Data.split(',')[0].indexOf('base64') &gt;= 0) byteString = atob(base64Data.split(',')[1]);//base64 解码 else{ byteString = unescape(base64Data.split(',')[1]); } var mimeString = base64Data.split(',')[0].split(':')[1].split(';')[0];//mime类型 -- image/png // var arrayBuffer = new ArrayBuffer(byteString.length); //创建缓冲数组 // var ia = new Uint8Array(arrayBuffer);//创建视图 var ia = new Uint8Array(byteString.length);//创建视图 for(var i = 0; i &lt; byteString.length; i++) { ia[i] = byteString.charCodeAt(i); } var blob = new Blob([ia], { type: mimeString }); return blob; } 4.blob流转换为base64 function blobToDataURI(blob, callback) { var reader = new FileReader(); reader.readAsDataURL(blob); reader.onload = function (e) { callback(e.target.result); } } 测试案例，可直接复制运行 &lt;input type=&quot;file&quot; id=&quot;imgfile&quot;&gt; &lt;\\img src=&quot;&quot; id=&quot;img&quot; alt=&quot;&quot;&gt; //这里图片总是转义，暂且这么写，知道是img就行 &lt;\\img src=&quot;&quot; id=&quot;img2&quot; alt=&quot;&quot;&gt; &lt;script&gt; document.getElementById('imgfile').onchange = function(){ reads(this.files[0],function(base64Data){ //获取图片的base64格式，显示 document.getElementById(&quot;img&quot;).src= reader.result; var blob = dataURItoBlob(reader.result); //转换为blob格式 blobToDataURI(blob,function(result){ //blob格式再转换为base64格式 document.getElementById('img2').src = result; }) }); } function reads(_file,callback){ var reader = new FileReader(); reader.readAsDataURL(_file); reader.onload = function(){ callback(reader.result); }; } function dataURItoBlob(base64Data) { //console.log(base64Data);//data:image/png;base64, var byteString; if(base64Data.split(',')[0].indexOf('base64') &gt;= 0) byteString = atob(base64Data.split(',')[1]);//base64 解码 else{ byteString = unescape(base64Data.split(',')[1]); } var mimeString = base64Data.split(',')[0].split(':')[1].split(';')[0];//mime类型 -- image/png // var arrayBuffer = new ArrayBuffer(byteString.length); //创建缓冲数组 // var ia = new Uint8Array(arrayBuffer);//创建视图 var ia = new Uint8Array(byteString.length);//创建视图 for(var i = 0; i &lt; byteString.length; i++) { ia[i] = byteString.charCodeAt(i); } var blob = new Blob([ia], { type: mimeString }); return blob; } function blobToDataURI(blob, callback) { var reader = new FileReader(); reader.readAsDataURL(blob); reader.onload = function (e) { callback(e.target.result); } } &lt;/script&gt; ","link":"https://lingtin.github.io/post/gxbNEPBuQ/"},{"title":"Github 开源指南","content":"文章来源：https://www.yuque.com/chenshuai/web/szlnbw Github 开源指南 github 上开源一个组件，并且内置到 umi+antd 系列中可以快速的得到更多的反馈，并且可以获得一些 PR 帮助我们的技术栈快速成长。但是Github 有一套自己的工作流，对于习惯内部系统的我们还是有一些上手成本，这篇文章会列举一些工具帮助我们更好的开始自己的开源生涯，早日成为名望程序员。 准备工作 GitHub 作为一个中心化的 git 管理平台，需要一个账号来进行开发和管理自己的仓库。注册号账号以后就可以 clone 仓库来进行开发了，以 antd 为例我们可以使用 ssh 和 https 两种方式进行开发，这里推荐使用ssh，https 的鉴权比较麻烦，经常会失败。 我们可以在 SSH 配置中 配置自己的 SSH keys，设置之后就可以完美的支持各种的仓库的 clone，如果还是想使用 https，推荐使用微软爸爸的提供的 GCMC 解决方案，并且安装 GitHub Desktop 和 VScode 的github 插件， vscode 提供了一个详细的教程来配置我们的工作流。 为了提升账号的安全性，我们推荐打开 GitHub 的两步验证，由于 GitHub 不支持中国大陆的手机，我们需要使用鉴权 App，这里推荐使用 微软 Authenticator 来支持，它可以方便的在国内使用。当然 google play 上还有一系列 APP, 可以自行选择。 如果我们需要管理一个仓库，推荐安装 gh ，GitHub 官方出品。 这里列举几个非常常用的命令： // 在浏览器中打开当前的仓库 gh repo view -w // 用当前的分支提一个pr gh pr create // 查看当前分支提供的 pr gh pr view -w 开发 一般而言 github 的工作流，会先 checkout 一个分支，在分支上开发完成之后，提交一个 PR， Approve 之后就可以就可以 merge 到 master 等待时间发布。 名词解释 PR pull requests 的简称，字面意思是希望别人 pull 你的代码，是希望仓库将你的代码合并到仓库中。常见用法 ： 来个 pr ？ lssue 字面意思是问题，是 github 提供的用来跟踪 bug 或者需求的工具,提了 issue 一般会异步解决。 常见用法 ： 提个 issue 吧 Collaborator_代表是某个仓库的维护人员，如果是某个仓库的 Collaborator 代表你给这个仓库贡献过代码。 常见用法： 我发现 xxx 有个错别字，正好去蹭个 Collaborator Approve _赞同，作为仓库的所有人同意了这个 pr之后，就可以点击 Approve 来同意这个提交，一般要求比较严格的仓库都需要至少一票 Approve 。常见用法： 乞讨 Approve 更多名字可以看这里 https://docs.github.com/cn/github/getting-started-with-github/github-glossary yarn 现在的 多 repo 已经非常多，为了方便的使用，一般会使用 learn+yarn ，yarn 的 workspaces 对多 repo 提供了良好的支持。这里推荐使用 tyarn。可以这样安装 : npm i yarn tyarn -g ## 工具 ### Actions github 提供了很多工具来提升我们的开发体验，基本上覆盖了我们全流程的开发任务，我们可以在 GitHub 上新建任务，管理 issue ，管理版本，发布网站，依托 github 提供的各种功能，我们可以更流畅的开发。 在开发阶段我们可以使用 github 中我们可以使用 github actions 来新建一个 CI。 只要在项目根目录中 .github/workflows 新建一个 xx.yml。这里有个简单的 CI 可以在每次 commit 中发起一个测试。 name: Node CI on: [push, pull_request] jobs: build: runs-on: ${{ matrix.os }} strategy: matrix: node_version: [12.x] os: [ubuntu-latest, windows-latest] steps: - uses: actions/checkout@v1 - name: Use Node.js ${{ matrix.node_version }} uses: actions/setup-node@v1 with: node-version: ${{ matrix.node_version }} - run: echo ${{github.ref}} - run: yarn - run: yarn run lint - run: yarn run tsc - run: yarn run build - run: yarn run test env: CI: true PROGRESS: none NODE_ENV: test NODE_OPTIONS: --max_old_space_size=4096 Issue 模板 在 .github 中 ISSUE_TEMPLATE 中新建一个xxx.md 可以提供一个 issue 的模板。 --- name: '疑问或需要帮助 ❓' about: 对 Ant Design Pro 使用的疑问或需要帮助 title: '🧐[问题]' labels: '🧐question' assignees: '' --- ### 🧐 问题描述 &lt;!-- 详细地描述问题，让大家都能理解 --&gt; ### 💻 示例代码 &lt;!-- 如果你有解决方案，在这里清晰地阐述 --&gt; ### 🚑 其他信息 &lt;!-- 如截图等其他信息可以贴在这里 --&gt; Pages GitHub 上有很多方便的 actions 模板可以轻松使用，例如 rebase 和 github pages，我们的项目开发到一定阶段时就需要一个网站来进行预览和发布。github 提供了 github pages 来帮助我们实现功能，它可以支持 https 和 自定义域名。我们一般会通过 CI 来发布 github pages, 这里有一个 actions 可以自动部署 mater 的代码到 github pages。 name: Deploy CI on: [push] jobs: build-and-deploy: runs-on: ubuntu-latest if: github.ref == 'refs/heads/master' steps: - name: Checkout uses: actions/checkout@master - run: yarn - run: npm run lint # - run: yarn run tsc - name: Build and Deploy uses: JamesIves/github-pages-deploy-action@master env: CI: true GA_KEY: UA-72788897-6 PROGRESS: none GIT_CONFIG_NAME: qixian.cs GIT_CONFIG_EMAIL: qixian.cs@outlook.com NODE_OPTIONS: --max_old_space_size=4096 ANT_DESIGN_PRO_ONLY_DO_NOT_USE_IN_YOUR_PRODUCTION: site GITHUB_TOKEN: ${{ secrets.ACTION_TOKEN }} BRANCH: gh-pages FOLDER: 'dist/' BUILD_SCRIPT: yarn &amp;&amp; npm run site &amp;&amp; git checkout . &amp;&amp; git clean -df 发布网站之后我们可能需要发布一下版本。这里推荐使用 np 来进行发布，可以减少发布的工作量，它提供了一个交互式 的发布工具来帮助我们发布版本。 更多的工具可以在 antd 的仓库抄一下 https://github.com/ant-design/ant-design/tree/master/.github 测试覆盖率 codecov 现在已经是事实上的标准，几乎每个开源库都会接入它。而且它是完全免费的。接入一个开源项目非常简单，只要一行代码。 bash &lt;(curl -s https://codecov.io/bash) 当然你要先去的官网注册一下，umi 也提供了 umi test:coverage 来支持 codecov。 badge badge 可以快速的展示一些小信息，帮助提升社会地位。 shields.io 支持各种 badge，你也可以自定义一下自己的 badge。 进阶 在进行了初始的开发之后我们就需要一些自定义之类的高端玩法。 自定义域名 这里推荐在 godaddy 购买域名，在 cloudflare 进行域名申请。我们只需要在 github 中增加对象 CNAME ，内容为你的域名，然后 cloudflare 简单的配置一下 包发布 npm 的 organizations 可以发布一系列的包，我们可以在 npm 中找到它。 查看包内容 pkg 可以方便的做到这一点，配合 yarn list 使用效果更佳 https://unpkg.com/packagename 统计 analytics 是真的方便，谁用谁知道，可以配合 https://umijs.org/plugins/plugin-analytics 一起使用。 ","link":"https://lingtin.github.io/post/JLj-ZHO_x/"},{"title":"Homebrew","content":"安装Homebrew https://brew.sh/ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 配置国内镜像 # 替换brew.git: $ cd &quot;$(brew --repo)&quot; # 中国科大: $ git remote set-url origin https://mirrors.ustc.edu.cn/brew.git # 清华大学: $ git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git # 替换homebrew-core.git: $ cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot; # 中国科大: $ git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git # 清华大学: $ git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git # 替换homebrew-bottles: # 中国科大: $ echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles' &gt;&gt; ~/.bash_profile $ source ~/.bash_profile # 清华大学: $ echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles' &gt;&gt; ~/.bash_profile $ source ~/.bash_profile # 应用生效: brew update 确定brew健康状况 # 确认brew在正常工作 brew doctor # update更新包 brew ","link":"https://lingtin.github.io/post/U18VlEloh/"},{"title":"Vue3源码-reactivity，effect，computed原理解析实现","content":"1、Vue3 Vue3 GitHub 地址：https://github.com/vuejs/vue-next 新版的Vue3主要是由 几个 package 为核心实现的 compiler-core ==&gt; 编译器核心； compiler-dom ==&gt; 浏览器渲染编辑模块; compiler-sfc ==&gt; 服务端渲染编译模块; runtime-dom ==&gt; 针对浏览器的运行时; runtime-core ==&gt; 运行时核心; reactivity ==&gt; 响应式系统; 2、reactiveity 实现 Vue2 响应式数据使用的是 defineProperty 属性，每次观察都需要增加getter和setter属性，如果有深层属性，会形成递归，递归会影响性能，如果对象是数组或深层对象，不能形成观察。 Vue3使用ES6的Proxy方式来解决这个问题。首先Proxy是支持数组的也就是数组是不需要做特别的代码的。对于深层监听也不不必要使用递归的方式解决。当get是判断值为对象时将对象做响应式处理返回。在大性能上得到很大的提升。 code... function reactive(data) { if (typeof data !== 'object' || data === null) { return data } const observed = new Proxy(data, { get(target, key, receiver) { // Reflect有返回值不报错 let result = Reflect.get(target, key, receiver) // 多层代理 return typeof result !== 'object' ? result : reactive(result) }, set(target, key, value, receiver) { effective() // proxy + reflect const ret = Reflect.set(target, key, value, receiver) return ret }, deleteProperty(target,key){ const ret = Reflect.deleteProperty(target,key) return ret } }) return observed } 3、effect 实现 Vue3的响应式核心主要是effect函数依赖。主要使用 Proxy 和 Reflect 进行对象代理和反射内部属性 做依赖收集，通过栈核心收集这个对象，每次对象发生变化时，去执行这个对象的属性的setter和gettter，触发依赖更新，总来的来说就会形成effect。 code... export function effect(fn, options) { // watch effect const effect = createReactiveEffect(fn, options) return effect } // 创建响应式的effect let uid = 0 // 创建一个唯一性id let activeEffect // 创建一个当前执行的 effect const effectStack = [] // 栈结构 类数组 收集effect function createReactiveEffect(fn, options) { const effect = function reactiveEffect() { if (effectStack.includes(effect)) { try { effectStack.push(effect) activeEffect = effect // 当前执行的是哪个effect return fn() } finally () { effectStack.pop() // 执行完之后 抛出 activeEffect = effectStack[effectStack.length - 1] // 当前执行的effect 也置空 } } } effect.id = uid++ effect.options = effect effect.dep = [] // 依赖的 effect return effect } // track const targetMap = new WeakMap() //用法和map一致 但是弱引用 不会导致内存泄漏 export function track(target, type, key) { // a = [effect,effect] b = [effect] if (activeEffect == undefined) { return // 说明取值的属性 不依赖于 effect } let depsMap = targetMap.get(target) // 根据key 来进行取值 if (!depsMap) { targetMap.set(target, (depsMap = new Map())) } let dep = depsMap.get(key) if (!dep) { depsMap.set(key, (dep = new Set())) } if (!dep.has(activeEffect)) { dep.add(activeEffect) // { &quot;{name:'zf'}&quot;:{name:set(effect)} } // activeEffect.deps.push(dep); // 让这个effect 记录dep属性 } } // trigger export function trigger(target, type, key, value, oldValue) { const depsMap = targetMap.get(target) // 获取当前对应的map if (!depsMap) { return } // 计算属性要优先于effect执行 const effects = new Set() const computedRunners = new Set() const add = (effectsToAdd) =&gt; { if (effectsToAdd) { effectsToAdd.forEach((effect) =&gt; { if (effect.options.computed) { computedRunners.add(effect) } else { effects.add(effect) } }) } } if (key !== null) { // arr.push(4) [1,2,3 , 4] push length add(depsMap.get(key)) } if (type === TriggerOpTypes.ADD) { // 对数组新增属性 会触发length 对应的依赖 在取值的时候回对length属性进行依赖收集 add(depsMap.get(Array.isArray(target) ? 'length' : '')) } const run = (effect) =&gt; { if (effect.options.scheduler) { effect.options.scheduler() } else { effect() } } computedRunners.forEach(run) effects.forEach(run) } 4、computed computed的实现 是在effect 之上实现的，computed可以实例自己的get和set方法， computed 是懒 执行，等需要时再执行，而不是 实例化就去执行的，这点和 effect不一样， // ----------- operation export const TrackOpTypes = { 'GET':'get' } export const TriggerOpTypes = { 'SET':'set', 'ADD':'add' } //----------- computed import { isFunction } from &quot;../shared/utils&quot;; import { effect, track, trigger } from &quot;./effect&quot;; import { TrackOpTypes, TriggerOpTypes } from &quot;./operation&quot;; export function computed(getterOrOptions) { let getter; let setter; if (isFunction(getterOrOptions)) { getter = getterOrOptions; setter = () =&gt; {} }else{ getter = getterOrOptions.get; setter = getterOrOptions.set; } let dirty = true; // 默认第一次取值是执行getter方法的 let computed; // 计算属性也是一个effect let runner = effect(getter,{ lazy:true, // 懒加载 computed:true, // 这里仅仅是标识而已 是一个计算属性 scheduler:()=&gt;{ if(!dirty){ dirty = true; // 等会就算属性依赖的值发生变化后 就会执行这个scheduler trigger(computed,TriggerOpTypes.SET,'value') } } }) let value; computed = { get value(){ if(dirty){ // 多次取值 不会重新执行effect value = runner(); dirty = false; track(computed,TrackOpTypes.GET,'value') } return value; }, set value(newValue){ setter(newValue); } } return computed; } ","link":"https://lingtin.github.io/post/vue3-0/"},{"title":"v2ray客户端使用","content":"V2Ray是一个优秀的开源网络代理工具，可以帮助你畅爽体验互联网，目前已经全平台支持Windows、Mac、Android、IOS、Linux等操作系统的使用。相对起Shadowsocks来说属于后起之秀，在混淆能力、兼容性、速度上有着独到的优点。在目前Shadowsocks、ShadowsocksR停止更新的情况下，多掌握一个活跃项目工具的使用是完全有必要的. 到目前为止，V2Ray项目的状况良好，衍生出一系列GUI客户端，而不再是原先单一的命令行工具。项目更名为Project V，而V2Ray则是Project V项目的内核，如果你对项目本身不感兴趣，依然可以按照原先的方式理解. 这里给大家一个链接 v2ray 官方文档 https://www.v2ray.com 神一样的工具 https://www.v2ray.com/awesome/tools.html 补充-----&gt; 这里是我偶尔逛论坛发现的一个 V2Ray 分享地址，由于 官方的 V2Ray地址被墙，推荐这里去查看分享。 tlanyan：https://tlanyan.me/v2ray-clients-download/ ","link":"https://lingtin.github.io/post/BXJ8qKOnd/"},{"title":"mysql学习速查记录","content":"查询总结 select 查询列表 ⑦ from 表1 别名 ① 连接类型 join 表2 ② on 连接条件 ③ where 筛选 ④ group by 分组列表 ⑤ having 筛选 ⑥ order by排序列表 ⑧ limit 起始条目索引，条目数; ⑨ 基础查询 一、语法 select 查询列表 from 表名; 二、特点 1、查询列表可以是字段、常量、表达式、函数，也可以是多个 2、查询结果是一个虚拟表 三、示例 1、查询单个字段 select 字段名 from 表名; 2、查询多个字段 select 字段名，字段名 from 表名; 3、查询所有字段 select * from 表名 4、查询常量 select 常量值; 注意：字符型和日期型的常量值必须用单引号引起来，数值型不需要 5、查询函数 select 函数名(实参列表); 6、查询表达式 select 100/1234; 7、起别名 ①as ②空格 8、去重 select distinct 字段名 from 表名; 9、+ 作用：做加法运算 select 数值+数值; 直接运算 select 字符+数值;先试图将字符转换成数值，如果转换成功，则继续运算；否则转换成0，再做运算 select null+值;结果都为null 10、【补充】concat函数 功能：拼接字符 select concat(字符1，字符2，字符3,...); 11、【补充】ifnull函数 功能：判断某字段或表达式是否为null，如果为null 返回指定的值，否则返回原本的值 select ifnull(commission_pct,0) from employees; 12、【补充】isnull函数 功能：判断某字段或表达式是否为null，如果是，则返回1，否则返回0 常见函数 一、概述 功能：类似于java中的方法 好处：提高重用性和隐藏实现细节 调用：select 函数名(实参列表); 二、单行函数 1、字符函数 concat:连接 substr:截取子串 upper:变大写 lower：变小写 replace：替换 length：获取字节长度 trim:去前后空格 lpad：左填充 rpad：右填充 instr:获取子串第一次出现的索引 2、数学函数 ceil:向上取整 round：四舍五入 mod:取模 floor：向下取整 truncate:截断 rand:获取随机数，返回0-1之间的小数 3、日期函数 now：返回当前日期+时间 year:返回年 month：返回月 day:返回日 date_format:将日期转换成字符 curdate:返回当前日期 str_to_date:将字符转换成日期 curtime：返回当前时间 hour:小时 minute:分钟 second：秒 datediff:返回两个日期相差的天数 monthname:以英文形式返回月 4、其他函数 version 当前数据库服务器的版本 database 当前打开的数据库 user当前用户 password('字符')：返回该字符的密码形式 md5('字符'):返回该字符的md5加密形式 5、流程控制函数 ①if(条件表达式，表达式1，表达式2)：如果条件表达式成立，返回表达式1，否则返回表达式2 ②case情况1 case 变量或表达式或字段 when 常量1 then 值1 when 常量2 then 值2 ... else 值n end ③case情况2 case when 条件1 then 值1 when 条件2 then 值2 ... else 值n end 三、分组函数 1、分类 max 最大值 min 最小值 sum 和 avg 平均值 count 计算个数 2、特点 ①语法 select max(字段) from 表名; ②支持的类型 sum和avg一般用于处理数值型 max、min、count可以处理任何数据类型 ③以上分组函数都忽略null ④都可以搭配distinct使用，实现去重的统计 select sum(distinct 字段) from 表; ⑤count函数 count(字段)：统计该字段非空值的个数 count(*):统计结果集的行数 案例：查询每个部门的员工个数 1 xx 10 2 dd 20 3 mm 20 4 aa 40 5 hh 40 count(1):统计结果集的行数 效率上： MyISAM存储引擎，count()最高 InnoDB存储引擎，count()和count(1)效率&gt;count(字段) ⑥ 和分组函数一同查询的字段，要求是group by后出现的字段 条件查询 一、语法 select 查询列表 from 表名 where 筛选条件 二、筛选条件的分类 1、简单条件运算符 &gt; &lt; = &lt;&gt; != &gt;= &lt;= &lt;=&gt;安全等于 2、逻辑运算符 &amp;&amp; and || or ! not 3、模糊查询 like:一般搭配通配符使用，可以判断字符型或数值型 通配符：%任意多个字符，_任意单个字符 between and in is null /is not null：用于判断null值 is null PK &lt;=&gt; 普通类型的数值 null值 可读性 is null × √ √ &lt;=&gt; √ √ × ","link":"https://lingtin.github.io/post/vcWhiwwan/"},{"title":"快速上手mongodb基本操作","content":"本文章，是学习过程中记录，只适合速度翻阅查看， 具体的文档可查看mongodb文档： https://docs.mongodb.com/manual 查看库 show dbs 切换到库 use 库名 查看集合（表） show collections || show tables 使用 insert 完成插入操作 操作格式： db.&lt;集合&gt;.insertOne(&lt;JSON对象&gt;) db.&lt;集合&gt;.insertMany([&lt;JSON 1&gt;, &lt;JSON 2&gt;, …]) 示例： db.nums.insertOne({name: &quot;001&quot;}) db.nums.insertMany([ {name: &quot;001&quot;}, {name: &quot;002&quot;}, {name: &quot;003&quot;} ]) 使用 find 查询文档 ● 关于 find: • find 是 MongoDB 中查询数据的基本指令，相当于 SQL 中的 SELECT 。 • find 返回的是游标。 ● find 示例： db.nums.find( { &quot;year&quot; : 1975 } ) //单条件查询 db.nums.find( { &quot;year&quot; : 1989, &quot;title&quot; : &quot;Batman&quot; } ) //多条件and查询 db.nums.find( { $and : [ {&quot;title&quot; : &quot;Batman&quot;}, { &quot;category&quot; : &quot;action&quot; }] } ) // and的另一种形式 db.nums.find( { $or: [{&quot;year&quot; : 1989}, {&quot;title&quot; : &quot;Batman&quot;}] } ) //多条件or查询 db.nums.find( { &quot;title&quot; : /^B/} ) //按正则表达式查找 查询条件对照表 SQL MQL a = 1 {a: 1} a &lt;&gt; 1 {a: {$ne: 1}} a &gt; 1 {a: {$gt: 1}} a &gt;= 1 {a: {$gte: 1}} a &lt; 1 {a: {$lt: 1}} a &lt;= 1 {a: {$lte: 1}} 查询逻辑对照表 SQL MQL a = 1 AND b = 1 {a: 1, b: 1}或{$and: [{a: 1}, {b: 1}]} a = 1 OR b = 1 {$or: [{a: 1}, {b: 1}]} a IS NULL {a: {$exists: false}} a IN (1, 2, 3) {a: {$in: [1, 2, 3]}} 查询逻辑运算符 ● $lt: 存在并小于 ● $lte: 存在并小于等于 ● $gt: 存在并大于 ● $gte: 存在并大于等于 ● $ne: 不存在或存在但不等于 ● $in: 存在并在指定数组中 ● $nin: 不存在或不在指定数组中 ● $or: 匹配两个或多个条件中的一个 ● $and: 匹配全部条件 使用 find 搜索子文档 ● find 支持使用“field.sub_field”的形式查询子文档。假设有一个文档： db.fruit.insertOne({ name: &quot;apple&quot;, from: { country: &quot;China&quot;, province: &quot;Guangdon&quot; } }) ● 考虑以下查询的意义： db.fruit.find( { &quot;from.country&quot; : &quot;China&quot; } ) db.fruit.find( { &quot;from&quot; : {country: &quot;China&quot;} } ) 使用 find 搜索数组 ● find 支持对数组中的元素进行搜索。假设有一个文档： db.fruit.insert([ { &quot;name&quot; : &quot;Apple&quot;, color: [&quot;red&quot;, &quot;green&quot; ] }, { &quot;name&quot; : &quot;Mango&quot;, color: [&quot;yellow&quot;, &quot;green&quot;] } ]) ● 考虑以下查询的意义： db.fruit.find({color: &quot;red&quot;}) db.fruit.find({$or: [{color: &quot;red&quot;}, {color: &quot;yellow&quot;}]} ) 使用 find 搜索数组中的对象 ● 考虑以下文档，在其中搜索 db.movies.insertOne( { &quot;title&quot; : &quot;Raiders of the Lost Ark&quot;, &quot;filming_locations&quot; : [ &quot;USA&quot; }, { &quot;city&quot; : &quot;Los Angeles&quot;, &quot;state&quot; : &quot;CA&quot;, &quot;country&quot; : { &quot;city&quot; : &quot;Rome&quot;, &quot;state&quot; : &quot;Lazio&quot;, &quot;country&quot; : &quot;Italy&quot; }, { &quot;city&quot; : &quot;Florence&quot;, &quot;state&quot; : &quot;SC&quot;, &quot;country&quot; : &quot;USA&quot; } ] }) • 查找城市是 Rome 的记录 • db.movies.find({&quot;filming_locations.city&quot;: &quot;Rome&quot;}) 使用 find 搜索数组中的对象 ● 在数组中搜索子对象的多个字段时，如果使用 $elemMatch，它表示必须是同一个 子对象满足多个条件。考虑以下两个查询： db.getCollection('movies').find({ &quot;filming_locations.city&quot;: &quot;Rome&quot;, &quot;filming_locations.country&quot;: &quot;USA&quot; }) db.getCollection('movies').find({ &quot;filming_locations&quot;: { $elemMatch:{&quot;city&quot;:&quot;Rome&quot;, &quot;country&quot;: &quot;USA&quot;} } }) 控制 find 返回的字段 ● find 可以指定只返回指定的字段； ● _id字段必须明确指明不返回，否则默认返回； ● 在 MongoDB 中我们称这为投影（projection）； ● db.movies.find({&quot;category&quot;: &quot;action&quot;},{&quot;_id&quot;:0, title:1}) 不返回_id 返回title 使用 remove 删除文档 ● remove 命令需要配合查询条件使用； ● 匹配查询条件的的文档会被删除； ● 指定一个空文档条件会删除所有文档； ● 以下示例： db.testcol.remove( { a : 1 } ) // 删除a 等于1的记录 db.testcol.remove( { a : { $lt : 5 } } ) // 删除a 小于5的记录 db.testcol.remove( { } ) // 删除所有记录 db.testcol.remove() //报错 使用 update 更新文档 ● Update 操作执行格式：db.&lt;集合&gt;.update(&lt;查询条件&gt;, &lt;更新字段&gt;) ● 以以下数据为例： db.fruit.insertMany([ {name: &quot;apple&quot;}, {name: &quot;pear&quot;}, {name: &quot;orange&quot;} ]) db.fruit.updateOne({name: &quot;apple&quot;}, {$set: {from: &quot;China&quot;}}) 查询 name 为apple 的记录将找到记录的 from设置为 China 使用 update 更新文档 ● 使用 updateOne 表示无论条件匹配多少条记录，始终只更新第一条； ● 使用 updateMany 表示条件匹配多少条就更新多少条； ● updateOne/updateMany 方法要求更新条件部分必须具有以下之一，否则将报错： • $set/$unset • $push/$pushAll/$pop • $pull/$pullAll • $addToSet ● // 报错 db.fruit.updateOne({name: &quot;apple&quot;}, {from: &quot;China&quot;}) 使用 update 更新数组 ● $push: 增加一个对象到数组底部 ● $pushAll: 增加多个对象到数组底部 ● $pop: 从数组底部删除一个对象 ● $pull: 如果匹配指定的值，从数组中删除相应的对象 ● $pullAll: 如果匹配任意的值，从数据中删除相应的对象 ● $addToSet: 如果不存在则增加一个值到数组 使用 drop 删除集合 ● 使用 db.&lt;集合&gt;.drop() 来删除一个集合 ● 集合中的全部文档都会被删除 ● 集合相关的索引也会被删除 db.colToBeDropped.drop() 使用 dropDatabase 删除数据库 ● 使用 db.dropDatabase() 来删除数据库 ● 数据库相应文件也会被删除，磁盘空间将被释放 use tempDB db.dropDatabase() show collections // No collections show dbs // The db is gone ","link":"https://lingtin.github.io/post/bdBaNcARw/"},{"title":"Linux 上安装 MongoDB","content":"$ mkdir -p /data /data/db $ cd /data $ curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-4.2.1.tgz $ tar -xvf mongodb-linux-x86_64-rhel70-4.2.1.tgz $ export PATH=PATH:/data/mongodb−linux−x8664−rhel70−4.2.1/binPATH:/data/mongodb-linux-x86_64-rhel70-4.2.1/bin PATH:/data/mongodb−linux−x866​4−rhel70−4.2.1/bin mongod --dbpath /data/db --port 27017 --logpath /data/db/mongod.log --fork –bind_ip 0.0.0.0 ","link":"https://lingtin.github.io/post/AhnTaALpE/"},{"title":"Mysql  ERROR 1045 (28000): Unknown error 1045","content":"最近在安装MySQL后在命令行登录报错：ERROR 1045 (28000): Unknown error 1045 在contos 7.5 通过yum或者是 giz 安装mysql ，安装完成后通过/etc/my.cnf配置文件找到MySQL的错误日志存在/var/log/mysql.log里，在该日志里查找到mysql的root用户的临时登录密码 [root@ip-172-31-34-225 log]# cat /var/log/mysqld.log | grep 'temporary password' 2019-02-13T10:32:25.917190Z 1 [Note] A temporary password is generated for root@localhost: #OHzhEURa 用临时密码通过命令行登录报错：ERROR 1045 (28000): Unknown error 1045 原因是密码错误,参考链接https://blog.csdn.net/nicolelili1/article/details/78833667（为什么初始的临时密码是错误的？这个还没弄明白） 解决方法是编辑 my.cnf vim /etc/my.cnf 在mysqld 的下一行 ，添加下面的代码，暂时跳过授权表实现免密登录 skip-grant-tasbles 然后重启 mysql systemctl restart mysqld 在命令行输入mysql回车即可登录，登录后设置新的root密码，下次通过新的密码即可登录 mysql update user set authentication_string = password('XXXXXX') where user = 'root'; Query OK, 1 row affected, 1 warning (0.00 sec) 刷新规则 flush privileges; Query OK, 0 rows affected (0.00 sec) 重新编辑 my.cnf ，把原来的 跳过免登录，给注释掉 vim /etc/my.cnf #skip-grant-tables #将该行注释然后重启mysql. 重启mysql systemctl restart mysqld 这次，你可以使用 mysql -u -p 然后输入密码登录了 ","link":"https://lingtin.github.io/post/Icz0c1eH6/"},{"title":"最好用的orm·typeorm(入门，实体)（typeorm/mysql）","content":"TypeORM 是一个 ORM 框架，它可以运行在 NodeJS、Browser、Cordova、PhoneGap、Ionic、React Native、Expo 和 Electron 平台上，可以与 TypeScript 和 JavaScript (ES5,ES6,ES7,ES8)一起使用。 它的目标是始终支持最新的 JavaScript 特性并提供额外的特性以帮助你开发任何使用数据库的（不管是只有几张表的小型应用还是拥有多数据库的大型企业应用）应用程序。 实体 本系列只在 nestjs 下使用typrorm。 安装 typrorm 和 mysql npm i @nestjs/typrorm typrorm mysql --save nestjs中使用 ，连接mysql app.module.ts 使用 TypeOrmModule 注册连接 mysql，填写mysql 配置 import { TypeOrmModule } from '@nestjs/typeorm'; @Module({ imports: [ TypeOrmModule.forRoot( { type: 'mysql', host: 'localhost', port: 3306, username: 'root', password: '123456', database: 'dengmi', entities: [__dirname + '/**/*.entity{.ts,.js}'], synchronize: true, },) ], controllers: [AppController, AdminController], providers: [AppService, ToolService, AdminService], }) export class AppModule {} 注册实体models 实体是一个映射到数据库表（或使用 MongoDB 时的集合）的类。 你可以通过定义一个新类来创建一个实体，并用@Entity()来标记。 在 src 目录下 新建entity 目录，新建 如 user.entity.ts，使用@Entity() 创建一个实体，@PrimaryGeneratedColumn() 创建主列 ，@Column() 创建列。 import { Entity, PrimaryGeneratedColumn, Column } from &quot;typeorm&quot;; @Entity() export class User { @PrimaryGeneratedColumn() id: number; @Column() firstName: string; @Column() lastName: string; @Column() age: number; } 这将创建以下数据库表： +-------------+--------------+----------------------------+ | user | +-------------+--------------+----------------------------+ | id | int(11) | PRIMARY KEY AUTO_INCREMENT | | firstName | varchar(255) | | | lastName | varchar(255) | | | isActive | boolean | | +-------------+--------------+----------------------------+ 基本实体由列和关系组成。 每个实体必须有一个主列（如果使用 MongoDB，则为 ObjectId 列）。 每个列可以获取任何类型的任何值。你也可以指定列类型。 如果未指定列类型，则将从属性类型自动推断。 实体列 @ Column 创建一个列，每个实体类属性都将映射到数据库表列。 @Entity() export class User { @Column() firstName: string; @Column() lastName: string; } @PrimaryGeneratedColumn() 创建的主列，该值使用自动增量自动生成，它将使用auto-increment /serial /sequence创建int列（取决于数据库）。 @Entity() export class User { @PrimaryGeneratedColumn() id: number; } @PrimaryGeneratedColumn(&quot;uuid&quot;) 创建的主列，该值将使用uuid自动生成。 Uuid 是一个独特的字符串 id，不必手动分配其值。 @Entity() export class User { @PrimaryGeneratedColumn(&quot;uuid&quot;) id: string; } @PrimaryColumn() 复合主列 @Entity() export class User { @PrimaryColumn() firstName: string; @PrimaryColumn() lastName: string; } 特殊列 @CreateDateColumn() 创建的列，自动为实体插入日期。无需设置此列，该值将自动设置。 @Entity() export class User { @CreateDateColumn() createTime:string } @UpdateDateColumn() 创建的列，在每次调用实体管理器或存储库的save时，自动更新实体日期。无需设置此列，该值将自动设置。 @Entity() export class User { @UpdateDateColumn() updateTime:string } @VersionColumn() 创建的列，在每次调用实体管理器或存储库的save时自动增长实体版本（增量编号）。无需设置此列，该值将自动设置。 @Entity() export class User { @VersionColumn() updateTime:string } 空间列 详情见https://typeorm.io/#/entities/%E7%A9%BA%E9%97%B4%E5%88%97 列类型 TypeORM 支持所有最常用的数据库支持的列类型。 列类型是特定于数据库类型的 - 这为数据库架构提供了更大的灵活性。 你可以将列类型指定为@ Column的第一个参数 或者在@Column的列选项中指定，例如： @Column(&quot;int&quot;) 或 @Column({ type: &quot;int&quot; }) 也可以插入其他类型 @Column(&quot;varchar&quot;, { length: 200 }) 或 @Column({ type: &quot;int&quot;, length: 200 }) mysql/mariadb的列类型 int, tinyint, smallint, mediumint, bigint, float, double, dec, decimal, numeric, date, datetime, timestamp, time, year, char, varchar, nvarchar, text, tinytext, mediumtext, blob, longtext, tinyblob, mediumblob, longblob, enum, json, binary, geometry, point, linestring, polygon, multipoint, multilinestring, multipolygon, geometrycollection enum 列类型 postgres和mysql都支持enum列类型，支持字符串，数字和异构枚举 使用typescript枚举： export enum UserRole { ADMIN = &quot;admin&quot;, EDITOR = &quot;editor&quot;, GHOST = &quot;ghost&quot; } @Entity() export class User { @PrimaryGeneratedColumn() id: number; @Column({ type: &quot;enum&quot;, enum: UserRole, default: UserRole.GHOST }) role: UserRole } 使用带枚举值的数组： export type UserRoleType = &quot;admin&quot; | &quot;editor&quot; | &quot;ghost&quot;, @Entity() export class User { @PrimaryGeneratedColumn() id: number; @Column({ type: &quot;enum&quot;, enum: [&quot;admin&quot;, &quot;editor&quot;, &quot;ghost&quot;], default: &quot;ghost&quot; }) role: UserRoleType } simple-array的列类型 有一种称为simple-array的特殊列类型，它可以将原始数组值存储在单个字符串列中。 所有值都以逗号分隔。 例如： @Entity() export class User { @PrimaryGeneratedColumn() id: number; @Column(&quot;simple-array&quot;) names: string[]; } const user = new User(); user.names = [&quot;Alexander&quot;, &quot;Alex&quot;, &quot;Sasha&quot;, &quot;Shurik&quot;]; 存储在单个数据库列中的Alexander，Alex，Sasha，Shurik值。 当你从数据库加载数据时，name 将作为 names 数组返回，就像之前存储它们一样。 注意：不能在值里面有任何逗号。 simple-json 列类型 还有一个名为simple-json的特殊列类型，它可以存储任何可以通过 JSON.stringify 存储在数据库中的值。 当你的数据库中没有 json 类型而你又想存储和加载对象，该类型就很有用了。 例如: @Entity() export class User { @PrimaryGeneratedColumn() id: number; @Column(&quot;simple-json&quot;) profile: { name: string; nickname: string }; } const user = new User(); user.profile = { name: &quot;John&quot;, nickname: &quot;Malkovich&quot; }; 存储在单个数据库列中的{“name”：“John”，“nickname”：“Malkovich”}值 当你从数据库加载数据时，将通过 JSON.parse 返回 object/array/primitive。 具有生成值的列 你可以使用@Generated装饰器创建具有生成值的列。 例如： @Entity() export class User { @PrimaryColumn() id: number; @Column() @Generated(&quot;uuid&quot;) uuid: string; } uuid值将自动生成并存储到数据库中。 除了&quot;uuid&quot;之外，还有&quot;increment&quot;生成类型，但是对于这种类型的生成，某些数据库平台存在一些限制（例如，某些数据库只能有一个增量列，或者其中一些需要增量才能成为主键）。 列选项 列选项定义实体列的其他选项。 你可以在@ Column上指定列选项： @Column({ type: &quot;varchar&quot;, length: 150, unique: true, // ... }) name: string; ColumnOptions中可用选项列表： type: ColumnType - 列类型。其中之一在上面. name: string - 数据库表中的列名。 默认情况下，列名称是从属性的名称生成的。 你也可以通过指定自己的名称来更改它。 length: number - 列类型的长度。 例如，如果要创建varchar（150）类型，请指定列类型和长度选项。 width: number - 列类型的显示范围。 仅用于MySQL integer types onUpdate: string - ON UPDATE触发器。 仅用于 MySQL. nullable: boolean - 在数据库中使列NULL或NOT NULL。 默认情况下，列是nullable：false。 update: boolean - 指示&quot;save&quot;操作是否更新列值。如果为false，则只能在第一次插入对象时编写该值。 默认值为&quot;true&quot;。 select: boolean - 定义在进行查询时是否默认隐藏此列。 设置为false时，列数据不会显示标准查询。 默认情况下，列是select：true default: string - 添加数据库级列的DEFAULT值。 primary: boolean - 将列标记为主要列。 使用方式和@ PrimaryColumn相同。 unique: boolean - 将列标记为唯一列（创建唯一约束）。 comment: string - 数据库列备注，并非所有数据库类型都支持。 precision: number - 十进制（精确数字）列的精度（仅适用于十进制列），这是为值存储的最大位数。仅用于某些列类型。 scale: number - 十进制（精确数字）列的比例（仅适用于十进制列），表示小数点右侧的位数，且不得大于精度。 仅用于某些列类型。 zerofill: boolean - 将ZEROFILL属性设置为数字列。 仅在 MySQL 中使用。 如果是true，MySQL 会自动将UNSIGNED属性添加到此列。 unsigned: boolean - 将UNSIGNED属性设置为数字列。 仅在 MySQL 中使用。 charset: string - 定义列字符集。 并非所有数据库类型都支持。 collation: string - 定义列排序规则。 enum: string[]|AnyEnum - 在enum列类型中使用，以指定允许的枚举值列表。 你也可以指定数组或指定枚举类。 asExpression: string - 生成的列表达式。 仅在MySQL中使用。 generatedType: &quot;VIRTUAL&quot;|&quot;STORED&quot; - 生成的列类型。 仅在MySQL中使用。 hstoreType: &quot;object&quot;|&quot;string&quot; -返回HSTORE列类型。 以字符串或对象的形式返回值。 仅在Postgres中使用。 array: boolean - 用于可以是数组的 postgres 列类型（例如 int []） transformer: { from(value: DatabaseType): EntityType, to(value: EntityType): DatabaseType } - 用于将任意类型EntityType的属性编组为数据库支持的类型DatabaseType。 注意：大多数列选项都是特定于 RDBMS 的，并且在MongoDB中不可用。 实体继承 你可以使用实体继承减少代码中的重复。 例如，你有Photo, Question, Post 三个实体: @Entity() export class Photo { @PrimaryGeneratedColumn() id: number; @Column() title: string; @Column() description: string; @Column() size: string; } @Entity() export class Question { @PrimaryGeneratedColumn() id: number; @Column() title: string; @Column() description: string; @Column() answersCount: number; } @Entity() export class Post { @PrimaryGeneratedColumn() id: number; @Column() title: string; @Column() description: string; @Column() viewCount: number; } 正如你所看到的，所有这些实体都有共同的列：id，title，description。 为了减少重复并产生更好的抽象，我们可以为它们创建一个名为Content的基类： export abstract class Content { @PrimaryGeneratedColumn() id: number; @Column() title: string; @Column() description: string; } @Entity() export class Photo extends Content { @Column() size: string; } @Entity() export class Question extends Content { @Column() answersCount: number; } @Entity() export class Post extends Content { @Column() viewCount: number; } 来自父实体的所有列（relations，embeds 等）（父级也可以扩展其他实体）将在最终实体中继承和创建。 树实体 TypeORM 支持存储树结构的 Adjacency 列表和 Closure 表模式。 邻接列表 邻接列表是一个具有自引用的简单模型。 这种方法的好处是简单，缺点是你不能因为连接限制而立刻加载一个树实体。 例如: import { Entity, Column, PrimaryGeneratedColumn, ManyToOne, OneToMany } from &quot;typeorm&quot;; @Entity() export class Category { @PrimaryGeneratedColumn() id: number; @Column() name: string; @Column() description: string; @OneToMany(type =&gt; Category, category =&gt; category.children) parent: Category; @ManyToOne(type =&gt; Category, category =&gt; category.parent) children: Category; } Closure 表 closure 表以特殊方式在单独的表中存储父和子之间的关系。 它在读写方面都很有效。 要了解有关 closure 表的更多信息，请查看 this awesome presentation by Bill Karwin. 例如: import { Entity, Tree, Column, PrimaryGeneratedColumn, TreeChildren, TreeParent, TreeLevelColumn } from &quot;typeorm&quot;; @Entity() @Tree(&quot;closure-table&quot;) export class Category { @PrimaryGeneratedColumn() id: number; @Column() name: string; @Column() description: string; @TreeChildren() children: Category; @TreeParent() parent: Category; @TreeLevelColumn() level: number; } ","link":"https://lingtin.github.io/post/typeorm0/"},{"title":"前端工程项目启动介绍","content":"😇此文章 专针对于 没有详细了解过 前端工程化项目的 同志们。 😇一般现代前端项目 都是基于 webpack 等打包工具打包的。 你可能拿到的项目是 如下图： 里面包含了 依赖描述文件 package.json 项目描述文件 README.md 先去用编辑器 打开 仔细阅读 README 文件,一般会在里面包含 1、项目说明 2、开发说明文档 3、注意事项 4、效果图 5、版权信息 启动项目（说明） 一般在查看README会有开发说明文档，如图 如果在 说明文档中没有写这些东西，可以打开package.json中查看，如下图 图中被圈起来的 scripts 部分，就是启动命令 使用时加入 npm run xxx 每个命令 意思 都跟上图的意思差不多，serve dev 都是本地启动，build build:prod 都是打包部署 一般打包完成后会生成一个dist 文件 实际操作（看图操作） 1 、 如果你的网速很慢走下图命令 (网速很快，或者 有安装过这个 就不用看这一步了) npm i -g nrm 安装完成后 切换远程源地址（如果这步操作错误，上面的步骤在跑一遍） nrm use taobao 2、安装依赖(耐心等待) npm install 3、启动项目 npm run serve 命令走完会跑代码，跑完之后一般会在 控制台有 本地预览地址 http://localhost 和局域网地址 http://192.168.x.xxx 4、打包项目 npm run build 一般会你的项目目录里有一个dist 的目录，就是打包后生成的，里面就是你熟悉的html文件，不过是压缩的。 ","link":"https://lingtin.github.io/post/IpEKe9S/"},{"title":"nestJs 介绍及安装 cli","content":"1、介绍 2、安装cli 介绍(官网) Nest 是一个用于构建高效，可扩展的 Node.js 服务器端应用程序的框架。它使用渐进式 JavaScript，内置并完全支持 TypeScript（但仍然允许开发人员使用纯 JavaScript 编写代码）并结合了 OOP（面向对象编程），FP（函数式编程）和 FRP（函数式响应编程）的元素。 在底层，Nest使用强大的 HTTP Server 框架，如 Express（默认）和 Fastify。Nest 在这些框架之上提供了一定程度的抽象，同时也将其 API 直接暴露给开发人员。这样可以轻松使用每个平台的无数第三方模块。 安装 在官网可以了解到 安装有三种方式（克隆项目、@nestjs/cli、命令行创建）。 || 这里推荐使用cli方式 1、首先安装 @nest/cli $ npm i -g @nestjs/cli 2、创建项目 $ nest new projectNew 3、cli创建后的目录及文件介绍 node_modules src // 主程序目录 --app.controller.ts // 控制器 --app.service.ts // 服务 --app.module.ts //模块 --main.ts //程序入口 test //测试目录 .gitignore .prettierrc nest-cli.json package.json README.md tsconfig.build.json tsconfig.json tslint.json yarn.lock 4、运行程序 $ npm run start 运行此命令在 src 目录中的 main.ts 文件中定义的端口上启动 HTTP 服务器。在应用程序运行时, 打开浏览器并访问 http://localhost:3000/。 你应该看到 Hello world! 信息 ","link":"https://lingtin.github.io/post/nest01/"},{"title":"CSS实现单行、多行文本溢出显示省略号（…）","content":"实现文本的溢出显示省略号几种方法 1、实现单行文本的溢出显示省略号... 2、实现多行文本溢出显示省略号... 如果实现单行文本的溢出显示省略号同学们应该都知道用text-overflow:ellipsis属性来，当然还需要加宽度width属来兼容部分浏览。 实现方法： overflow: hidden; text-overflow:ellipsis; white-space: nowrap; 效果如： 实现单行文本的溢出显示省略号... 但是这个属性只支持单行文本的溢出显示省略号，如果我们要实现多行文本溢出显示省略号呢。 接下来重点说一说多行文本溢出显示省略号，如下。 WebKit浏览器或移动端的页面 在WebKit浏览器或移动端（绝大部分是WebKit内核的浏览器）的页面实现比较简单，可以直接使用WebKit的CSS扩展属性(WebKit是私有属性)-webkit-line-clamp ；注意：这是一个 不规范的属性（unsupported WebKit property），它没有出现在 CSS 规范草案中。 实现方法： display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; overflow: hidden; 效果如图： 实现多行文本的溢出显示省略号 实现多行文本的溢出显示省略号 实现多行文本的溢出显示省... 适用范围： 因使用了WebKit的CSS扩展属性，该方法适用于WebKit浏览器及移动端； 注： -webkit-line-clamp用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的 WebKit属性。常见结合属性： display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。 -webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。 实现方法： p{position: relative; line-height: 20px; max-height: 40px;overflow: hidden;} p::after{content: &quot;...&quot;; position: absolute; bottom: 0; right: 0; padding-left: 40px; background: -webkit-linear-gradient(left, transparent, #fff 55%); background: -o-linear-gradient(right, transparent, #fff 55%); background: -moz-linear-gradient(right, transparent, #fff 55%); background: linear-gradient(to right, transparent, #fff 55%); } 适用范围： 该方法适用范围广，但文字未超出行的情况下也会出现省略号,可结合js优化该方法。 注： 将height设置为line-height的整数倍，防止超出的文字露出。 给p::after添加渐变背景可避免文字只显示一半。 由于ie6-7不显示content内容，所以要添加标签兼容ie6-7（如：…）；兼容ie8需要将 ::after替换成:after。 跨浏览器兼容的方案 比较靠谱简单的做法就是设置相对定位的容器高度，用包含省略号(…)的元素模拟实现； 例如： p { position:relative; line-height:1.4em; /* 3 times the line-height to show 3 lines */ height:4.2em; overflow:hidden; } p::after { content:&quot;...&quot;; font-weight:bold; position:absolute; bottom:0; right:0; padding:0 20px 1px 45px; background:url(/newimg88/2014/09/ellipsis_bg.png) repeat-y; } 效果如： WebKit Browsers will clamp the number of lines in this paragraph to 2. Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat... 这里注意几点： height高度真好是line-height的3倍； 结束的省略好用了半透明的png做了减淡的效果，或者设置背景颜色； IE6-7不显示content内容，所以要兼容IE6-7可以是在内容中加入一个标签，比如用&lt;span class=&quot;line-clamp&quot;&gt;...&lt;/span&gt;去模拟； 要支持IE8，需要将::after替换成:after； JavaScript 方案 用js也可以根据上面的思路去模拟，实现也很简单，推荐几个做类似工作的成熟小工具： 1.Clamp.js 下载及文档地址：https://github.com/josephschmitt/Clamp.js 使用也非常简单： var module = document.getElementById(&quot;clamp-this-module&quot;); $clamp(module, {clamp: 3}); 2.jQuery插件-jQuery.dotdotdot 这个使用起来也很方便： $(document).ready(function() { $(&quot;#wrapper&quot;).dotdotdot({ // configuration goes here }); }); ","link":"https://lingtin.github.io/post/WMjMr42Ik/"},{"title":"H5页面前端开发，大多数人都会遇到的几个兼容性坑","content":"H5页面前端开发，大多数人都会遇到的几个兼容性坑 1、ios端兼容input光标高度 2、ios端微信h5页面上下滑动时卡顿、页面缺失 作者：codercao 来源：https://juejin.im/post/5d47d2eff265da03f77e4e3a 所以下文涉及图片都模糊处理了。 1、ios端兼容input光标高度 问题详情描述：input输入框光标，在安卓手机上显示没有问题，但是在苹果手机上当点击输入的时候，光标的高度和父盒子的高度一样。例如下图，左图是正常所期待的输入框光标，右边是ios的input光标。 出现原因分析：通常我们习惯用height属性设置行间的高度和line-height属性设置行间的距离（行高），当点击输入的时候，光标的高度就自动和父盒子的高度一样了。（谷歌浏览器的设计原则，还有一种可能就是当没有内容的时候光标的高度等于input的line-height的值，当有内容时，光标从input的顶端到文字的底部 解决办法：高度height和行高line-height内容用padding撑开 例如： .content{ float: left; box-sizing: border-box; height: 88px; width: calc(100% - 240px); .content-input{ display: block; box-sizing: border-box; width: 100%; color: #333333; font-size: 28px; //line-height: 88px; padding-top: 20px; padding-bottom: 20px; } } 2、ios端微信h5页面上下滑动时卡顿、页面缺失 问题详情描述：在ios端，上下滑动页面时，如果页面高度超出了一屏，就会出现明显的卡顿，页面有部分内容显示不全的情况，例如下图，右图是正常页面，边是ios上下滑动后，卡顿导致如左图下面部分丢失。 出现原因分析： 笼统说微信浏览器的内核，Android上面是使用自带的WebKit内核，iOS里面由于苹果的原因，使用了自带的Safari内核，Safari对于overflow-scrolling用了原生控件来实现。对于有-webkit-overflow-scrolling的网页，会创建一个UIScrollView，提供子layer给渲染模块使用。【有待考证】 解决办法：只需要在公共样式加入下面这行代码 *{ -webkit-overflow-scrolling: touch; } But，这个属性是有bug的，比如如果你的页面中有设置了绝对定位的节点，那么该节点的显示会错乱，当然还有会有其他的一些bug。 拓展知识： -webkit-overflow-scrolling:touch是什么？ MDN上是这样定义的： -webkit-overflow-scrolling 属性控制元素在移动设备上是否使用滚动回弹效果. auto: 使用普通滚动, 当手指从触摸屏上移开，滚动会立即停止。 touch: 使用具有回弹效果的滚动, 当手指从触摸屏上移开，内容会继续保持一段时间的滚动效果。继续滚动的速度和持续的时间和滚动手势的强烈程度成正比。同时也会创建一个新的堆栈上下文。 3、ios键盘唤起，键盘收起以后页面不归位 问题详情描述： 输入内容，软键盘弹出，页面内容整体上移，但是键盘收起，页面内容不下滑 出现原因分析： 固定定位的元素 在元素内 input 框聚焦的时候 弹出的软键盘占位 失去焦点的时候软键盘消失 但是还是占位的 导致input框不能再次输入 在失去焦点的时候给一个事件 解决办法： &lt;div class=&quot;list-warp&quot;&gt; &lt;div class=&quot;title&quot;&gt;&lt;span&gt;投·被保险人姓名&lt;/span&gt;&lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;input class=&quot;content-input&quot; placeholder=&quot;请输入姓名&quot; v-model=&quot;peopleList.name&quot; @focus=&quot;changefocus()&quot; @blur.prevent=&quot;changeBlur()&quot;/&gt; &lt;/div&gt; &lt;/div&gt; changeBlur(){ let u = navigator.userAgent, app = navigator.appVersion; let isIOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/); if(isIOS){ setTimeout(() =&gt; { const scrollHeight = document.documentElement.scrollTop || document.body.scrollTop || 0 window.scrollTo(0, Math.max(scrollHeight - 1, 0)) }, 200) } } 拓展知识： position: fixed的元素在ios里，收起键盘的时候会被顶上去，特别是第三方键盘 4、安卓弹出的键盘遮盖文本框 问题详情描述： 安卓微信H5弹出软键盘后挡住input输入框，如下左图是期待唤起键盘的时候样子，右边是实际唤起键盘的样子 出现原因分析：待补充 解决办法：给input和textarea标签添加focus事件，如下，先判断是不是安卓手机下的操作，当然，可以不用判断机型，Document 对象属性和方法，setTimeout延时0.5秒，因为调用安卓键盘有一点迟钝，导致如果不延时处理的话，滚动就失效了 changefocus(){ let u = navigator.userAgent, app = navigator.appVersion; let isAndroid = u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1; if(isAndroid){ setTimeout(function() { document.activeElement.scrollIntoViewIfNeeded(); document.activeElement.scrollIntoView(); }, 500); } } 拓展知识： Element.scrollIntoView()方法让当前的元素滚动到浏览器窗口的可视区域内。而Element.scrollIntoViewIfNeeded()方法也是用来将不在浏览器窗口的可见区域内的元素滚动到浏览器窗口的可见区域。但如果该元素已经在浏览器窗口的可见区域内，则不会发生滚动 5、Vue中路由使用hash模式，开发微信H5页面分享时在安卓上设置分享成功，但是ios的分享异常 问题详情描述： ios当前页面分享给好友，点击进来是正常，如果二次分享，则跳转到首页；使用vue router跳转到第二个页面后在分享时，分享设置失败；以上安卓分享都是正常 出现原因分析：jssdk是后端进行签署，前端校验，但是有时跨域，ios是分享以后会自动带上 from=singlemessage&amp;isappinstalled=0 以及其他参数，分享朋友圈参数还不一样，貌似系统不一样参数也不一样，但是每次获取url并不能获取后面这些参数 解决办法： （1）可以使用改页面this.$router.push跳转，为window.location.href去跳转，而不使用路由跳转，这样可以使地址栏的地址与当前页的地址一样，可以分享成功（适合分享的页面不多的情况下，作为一个单单页运用，这样刷新页面跳转，还是..） （2）把入口地址保存在本地，等需要获取签名的时候 取出来，注意：sessionStorage.setItem(‘href’,href); 只在刚进入单应用的时候保存！【该方法未验证】 ","link":"https://lingtin.github.io/post/gdCbgzQi/"},{"title":"bignumber.js使用记录","content":"bignumber.js是一个用于进行数学运算的库，支持任意精度。 1、constructor 2、静态方法 本文可以看做是对bignumber.js官方文档的翻译。 constructor /* * n {number|string|BigNumber} A numeric value. * [b] {number} The base of n. Integer, 2 to ALPHABET.length inclusive. */ function BigNumber(n, b) { } 静态方法 clone() 生成一个独立的BigNumber构造函数 var BN = BigNumber.clone() BN(1).div(3).toNumber() //0.3333333333333333 config() 为这个独立的BigNumber构造函数设置参数 主要包括以下几个参数： DECIMAL_PLACES(默认值：20) 用于设置小数位数。在除法、开方、指数计算时会用到。 var BN = BigNumber.clone() BN.config({DECIMAL_PLACES:4}) BN(1).div(3).toNumber() //0.3333，注意跟上面计算结果的区别 ROUNDING_MODE(默认值4) 舍入模式，取值的意义可参照 //取值范围： BigNumber.ROUND_UP = 0; //远离0方向舍入 BigNumber.ROUND_DOWN = 1; //向0方向舍入 BigNumber.ROUND_CEIL = 2; //向正无限大舍入 BigNumber.ROUND_FLOOR = 3; //向负无限大舍入 BigNumber.ROUND_HALF_UP = 4; //四舍五入：向最接近的数字方向舍入，如果与两个相邻数字的距离相等，则向上舍入。 BigNumber.ROUND_HALF_DOWN = 5; //向最接近的数字方向舍入，如果与两个相邻数字的距离相等，则向下舍入。 BigNumber.ROUND_HALF_EVEN = 6; //向最接近数字方向舍入，如果与两个相邻数字的距离相等，则向相邻的偶数舍入 BigNumber.ROUND_HALF_CEIL = 7; BigNumber.ROUND_HALF_FLOOR = 8; EXPONENTIAL_AT(默认值[-7,20]) 指数计数法 RANGE(默认值[-1e+9,1e+9]) CRYPTO(默认值 false) 用于设置BigNumber.random()的随机生成算法。如果无法设置为true，则使用Math.random()生成随机值。 MODULO_MODE(默认值：ROUND_DOWN) 取模运算的模式 POW_PRECISION(默认值：0) pow运算结果的精度 FORMATE(格式化对应的设置) 默认值： BigNumber.config().FORMAT ============================== { decimalSeparator: &quot;.&quot; fractionGroupSeparator: &quot; &quot; fractionGroupSize: 0 groupSeparator: &quot;,&quot; groupSize: 3 secondaryGroupSize: 0 } maximum([]),minimum([]) 获取数组中的最大值/最小值 random([precision]) 返回一个伪随机值，参数可以指定小数点位数 实例方法 加法：.plus(n [, base]) ⇒ BigNumber 0.1 + 0.2 // 0.30000000000000004 x = new BigNumber(0.1) y = x.plus(0.2) // '0.3' BigNumber(0.7).plus(x).plus(y) // '1' x.plus('0.1', 8) // '0.225' 减法：.minus(n [, base]) ⇒ BigNumber 0.3 - 0.1 // 0.19999999999999998 x = new BigNumber(0.3) x.minus(0.1) // '0.2' x.minus(0.6, 20) // '0' 乘法：.times(n [, base]) ⇒ BigNumber; m.ultipliedBy(n [, base]) ⇒ BigNumber; 0.6 * 3 // 1.7999999999999998 x = new BigNumber(0.6) y = x.multipliedBy(3) // '1.8' BigNumber('7e+500').times(y) // '1.26e+501' x.multipliedBy('-a', 16) // '-6 除法 普通除法运算： .div(n [, base]) ⇒ BigNumber； .dividedBy(n [, base]) ⇒ BigNumber x = new BigNumber(355) y = new BigNumber(113) x.dividedBy(y) // '3.14159292035398230088' x.div(5) // '71' x.div(47, 16) // '5' 注意： 除法计算结果会根据DECIMAL_PLACES和ROUNDING_MODE两个属性设置进行舍入。 除法，返回整数： .idiv(n [, base]) ⇒ BigNumber；.dividedToIntegerByv(n [, base]) ⇒ BigNumber x = new BigNumber(355) y = new BigNumber(113) x.dividedBy(y) // '3.14159292035398230088' x.div(5) // '71' x.div(47, 16) // '5' 取模/取余： .mod(n [, base]) ⇒ BigNumber；modulo.(n [, base]) ⇒ BigNumber 1 % 0.9 // 0.09999999999999998 x = new BigNumber(1) x.modulo(0.9) // '0.1' y = new BigNumber(33) y.mod('a', 33) // '3' 注意： 取模/取余运算受MODULO_MODE设置影响 指数运算： .pow(n [, m]) ⇒ BigNumber;.exponentiatedBy(n [, m]) ⇒ BigNumber Math.pow(0.7, 2) // 0.48999999999999994 x = new BigNumber(0.7) x.exponentiatedBy(2) // '0.49' BigNumber(3).pow(-2) // '0.11111111111111111111' 开平方：.sqrt() ⇒ BigNumber；.squareRoot.() ⇒ BigNumber x = new BigNumber(16) x.squareRoot() // '4' y = new BigNumber(3) y.sqrt() // '1.73205080756887729353' 比较大小： .comparedTo(n [, base]) ⇒ number 比较结果，参考如下表： 1 操作数&gt;n -1 操作数&lt;n 0 操作数==n null 操作数或者n不是数字 复制代码举例： x = new BigNumber(Infinity) y = new BigNumber(5) x.comparedTo(y) // 1 x.comparedTo(x.minus(1)) // 0 y.comparedTo(NaN) // null y.comparedTo('110', 2) // -1 精度调整 .dp([dp [, rm]]) ⇒ BigNumber|number；decimalPlaces.[dp [, rm]]) ⇒ BigNumber|number 根据dp(decimals places)和rm(round mode)对操作数进行舍入 x = new BigNumber(1234.56) x.decimalPlaces(1) // '1234.6' x.dp() // 2 如果不传dp，则函数返回的是操作数的小数点的位数 x.decimalPlaces(2) // '1234.56' x.dp(10) // '1234.56' x.decimalPlaces(0, 1) // '1234' x.dp(0, 6) // '1235' x.decimalPlaces(1, 1) // '1234.5' x.dp(1, BigNumber.ROUND_HALF_EVEN) // '1234.6' x // '1234.56' 取整：.integerValue([rm]) ⇒ BigNumber 根据rm(round mode)返回操作数的整数部分 x = new BigNumber(123.456) x.integerValue() // '123' x.integerValue(BigNumber.ROUND_CEIL) // '124' y = new BigNumber(-12.7) y.integerValue() // '-13' y.integerValue(BigNumber.ROUND_DOWN) // '-12',向0舍入 有效数字 .sd([d [, rm]]) ⇒ BigNumber|number；precision.([d [, rm]]) ⇒ BigNumber|number 什么是有效数字？---&gt;从该数的第一个非零数字起，直到末尾数字止的数字称为有效数字，如0.618的有效数字有三个，分别是6,1,8。 x = new BigNumber(9876.54321) x.precision(6) // '9876.54' x.sd() // 9 如果省略参数d，则返回有效数字个数 x.precision(6, BigNumber.ROUND_UP) // '9876.55' x.sd(2) // '9900' //todo x.precision(2, 1) // '9800' //todo y = new BigNumber(987000) y.precision() // 3 y.sd(true) // 6,如多参数sd为true，则整数部分后边的0也会被认为是有效数字 .toFixed([dp [, rm]]) ⇒ string 返回一个字符串，小数位根据dp截取或者填充。 注意： Unlike Number.prototype.toFixed, which returns exponential notation if a number is greater or equal to 1021, this method will always return normal notation. 跟Number.prototype.toFixed(dp)的异同 如果省略参数dp，BigNumber(1.123).toFixed() 原样返回'1.123';而1.123.toFixed()会去掉所有小数位，只返回整数位'1' 如果操作数大于1021，BigNumber(1021).toFixed()会跟普通数字一样返回；10^21.toFixed() 会通过指数形式返回 Math.pow(10,20).toFixed() //&quot;100000000000000000000&quot; Math.pow(10,21).toFixed() //&quot;1e+21&quot; BigNumber(10).pow(20).toFixed() //&quot;100000000000000000000&quot; BigNumber(10).pow(21).toFixed() //&quot;1000000000000000000000&quot; 示例： x = 3.456 y = new BigNumber(x) x.toFixed() // '3' y.toFixed() // '3.456' y.toFixed(0) // '3' x.toFixed(2) // '3.46' y.toFixed(2) // '3.46' y.toFixed(2, 1) // '3.45' (ROUND_DOWN) x.toFixed(5) // '3.45600' y.toFixed(5) // '3.45600' 注意： toFixed()方法与dp()方法的主要区别是，toFixed返回的是字符串，如果小数位不够的话会用0补齐；dp()方法返回的是BigNumber|number，小数位不够的话会忽略 数字格式化 .toFormat([dp [, rm]]) ⇒ string 返回字符串，会根据dp和rm进行舍入,并根据FORMAT属性进行格式化。 format = { decimalSeparator: '.', groupSeparator: ',', groupSize: 3, secondaryGroupSize: 0, fractionGroupSeparator: ' ', fractionGroupSize: 0 } BigNumber.config({ FORMAT: format }) x = new BigNumber('123456789.123456789') x.toFormat() // '123,456,789.123456789' x.toFormat(1) // '123,456,789.1' 转换为js 基础数值类型 .toNumber() ⇒ number 效果与使用+运算符一致 x = new BigNumber(456.789) x.toNumber() // 456.789 +x // 456.789 链接：https://juejin.im/post/5be00d15e51d451bc70bfa26 来源：掘金 ","link":"https://lingtin.github.io/post/dV9qteBys/"},{"title":"CMD同时运行多个服务","content":"主要是方便我们写前端工程化的时候，我们可以同时启动多个命令用。 1、安装concurrently 2、package.json 文档地址：https://www.npmjs.com/package/concurrentl 一、安装 //使用node编写时 npm install -g concurrently //或者cnpm在项目里 cnpm install concurrently --save 二、package.json scripts:{ &quot;watch-start&quot;:&quot;...&quot;, &quot;watch-server&quot;:&quot;...&quot;, &quot;watch-dreams&quot;:&quot;...&quot; } 三、命令行启动 //命令带上引号 concurrently &quot;npm run dev&quot; &quot;npm run build&quot; &quot;npm run server&quot; //或者运行某字段为前缀的命令 concurrently &quot;npm:watch-*&quot; 来源链接：https://zhuanlan.zhihu.com/p/65564606 来源：知乎 ","link":"https://lingtin.github.io/post/concurrently01/"},{"title":"使用nodejs编写cli(命令行)","content":"使用nodejs编写cli(命令行) 1、跑node脚本 2、node的执行程序 前端日常开发中，会遇见各种各样的cli，比如一行命令帮你打包的webpack，一行命令帮你生成vue项目模板的vue-cli，还有创建react项目的create-react-app等等等等。这些工具极大地方便了我们的日常工作，让计算机自己去干繁琐的工作，而我们，就可以节省出大量的时间用于学习、交流、开发、逛steam。 但是有时候一些十分特别的需求，我们是找不到适合的cli工具去做的。比如说，你的项目十分庞大，你给项目添加一个新的路由，要经过创建目录 -&gt; 创建.vue文件 -&gt; 更新vue-router的路由列表这一趟流程，就算快捷键创建目录文件用得再熟悉，也比不过你一行命令来得快，特别是路由目录嵌套深，.vue文件初始化模板复杂的时候。 所以呢，何不为自己项目写一个cli？就专门做这些繁琐的活？ 0x1 hello world nodejs的cli，本质就是跑node脚本嘛，基本上每位前端er都会： // index.js console.log('hello world') 然后命令行调用 &gt; node index.js 输出： &gt; hello world 可以做得更逼真一点，我们在package.json里面的scripts字段上添加一下脚本名： { &quot;scripts&quot;:{ &quot;hello&quot;:&quot;node index.js&quot; } } 然后命令行调用： &gt; npm run hello 但是，看到这里你肯定会说，人家webpack还有vue-cli都是“有名字”的！什么vue-cli init app、webpack -p的，多漂亮，看看这个命令行，node index.js，还npm run hello，谁不会啊，丑不拉几的，怕又不是来水文章的哦？差评！！ 别急啊各位大人，接下来就说说，如何给这个node脚本起个名字。 0x2 起名字 姑且，先把这个cli的名字命名为hello-cli，就是我们能够在命令行里面，输入hello-cli，然后它就打印一句hello world，没有node也没有npm，就是： 这里，我们需要做几步操作： index.js文件顶部声明执行环境： // index.js #!/usr/bin/env node console.log('hello world') 添加#!/usr/bin/env node或者#!/usr/bin/node，这是告诉系统，下面这个脚本，使用nodejs来执行。当然，这个系统不包括windows，因为windows下有个JScript的历史遗留物在，会让你的脚本跑不起来。 #!/usr/bin/env node的意思是让系统自己去找node的执行程序。 #!/usr/bin/node的意思是，明确告诉系统，node的执行程序在路径为/usr/bin/node。 添加package.json的bin字段。 可以在index.js当前的目录下执行npm init创建一个package.json，然后在package.json里面，添加一个bin字段： { &quot;name&quot;: &quot;hello-test&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;bin&quot;:{ &quot;hello-cli&quot;:&quot;index.js&quot; } } bin字段里面写上这个命令行的名字，也就是hello-cli，它告诉npm，里面的js脚本可以通过命令行的方式执行，以hello-cli的命令调用。当然命令行的名字你想写什么都是你的自由。 在当前package.json目录下，打开命令行工具，执行npm link，将当前的代码在npm全局目录下留个快捷方式。 npm检测到package.json里面存在一个bin字段，它就同时在全局npm包目录下生成了一个可执行文件： 当我们在系统命令行直接执行hello-cli的时候，实际上就是执行这里的脚本。 因为安装node的时候，npm将这个目录配置为系统变量环境了，当你执行命令的时候，系统会先找系统命令和系统变量，然后到变量环境里面去查找这个命令名，然后找到这个目录后，发现匹配上了该命令名的可执行文件，接着就直接执行它。vue-cli也好，webpack-cli也好，都是这样执行的。 这样，你的第一个cli脚本就成功安装了，可以在命令行里面，直接敲你的cli名字，看看结果输出吧。 另外，如果你仅希望你的cli脚本仅在项目里执行，则需要在你项目里面新建一个目录，重复上述的操作，只是在第三步的时候，不要llink到全局里面去，而是使用npm i -D file:&lt;你的脚本cli目录路径&gt;，把它当成项目的依赖安装到node_modules里面去，如果安装成功，那么在项目的package.json你会看到多了一条依赖，这条依赖的值不是版本号，而是你脚本的路径。然后在node_modules里面会有一个.bin目录，里面就存放着你的可执行文件。 局部安装建议用npm i -D file:xxx，这样它会在package.json留条记录，方便其他小伙伴看到。自然，你的脚本最好也是放进项目目录里面。 当然，这样安装的cli脚本，必须在项目的package.json的scripts字段上声明脚本命令，然后通过npm run的方式执行 哦？这样子使用的话不就回到最最最开始的时候那种原始的npm run hello一样么。 是的，但是有质的区别。使用node index.js这种方式调用的话固然简单灵活，但是严重依赖脚本路径，一旦目录结构发生变动，写在scripts的命令就要更改一次；但是使用npm安装之后，本地的cli脚本就被拉到node_modules里面，目录结构变动对其影响不大。其次是不利于分享与发布，如果你想把你的cli脚本发布出去，那么有一个好听响亮的名字，比起在说明文档里面告诉使用者如何找到你的脚本路径再用node执行它，简直好上那么一万倍不是么？ 这里也给我们提供了一个cli开发流程思路： 初期开发可以通过node index.js来看效果。 测试的时候可以通过npm link的方式进行安装测试。 发布 0x3 参数读取:process.argv 名字有了，输出也有了，看看我们跟那些大名鼎鼎的cli工具，在形式上还差点啥？对了，人家可以支持不同参数选项的，还可以根据输入的不同，产生不同的结果。 这样吧，我们给这个cli加一个功能，既然叫hello-cli，那不能只会hello world吧，必须要见谁就说hello才行： &gt; hello-cli older &gt; 输出 &gt; hello older 虽然这个功能很简单，但是至少也是实现了“根据输入的不同，产生不同结果”的效果。 命令行上的参数，可以通过process这个变量获取，process是一个全局对象而不是一个包，不需要通过require引入。通过process这个对象我们可以拿到当前脚本执行环境等一系列信息，其中就包括命令行的输入情况，这个信息，保存在process.argv这个属性里。我们可以打印一下： //index.js console.log(process.argv); argv是个数组，前两位是固定的，分别是node程序的路径和脚本存放的位置，从第三位开始才是额外输入的内容。那么实现上面的功能就很简单了，只要读取argv数组的第三位，然后输出出来就可以了。 //index.js console.log(`hello ${process.argv[2]||'world'}`) npm社区中也有一些优秀的命令行参数解析包，比如yargs,tj的commander.js等等 如果你想使用比较复杂的参数或者命令，建议还是用第三方包比较好，手写解析太耗精力了。 0x4 子进程 现在，你可以自由自在的写你自己的cli脚本了。 如果你希望写一个项目打完包自动推上git的cli，或者自动从git仓库里面拉取项目启动模板，那么，你需要通过node的child_process模块开启子进程，在子进程内调用git命令： //test.js const child_process = require('child_process'); let subProcess=child_process.exec(&quot;git version&quot;,function(err,stdout){ if(err)console.log(err); console.log(stdout); subProcess.kill() }); 不仅是git命令，包括系统命令、其他cli命令都可以在这里执行。特别是系统命令，使用系统命令对文件目录进行操作，效率比fs高到不知道哪里去了。 社区上也有一些不错的包，比如阮一峰老师推荐的shelljs 0x5 美化输出 如果你不那么希望你的cli用起来那么“硬核”，希望更人性化一点，比如提供一些友好的输入、提示啊，给你的输出加点颜色区分重点啊，写个简单的进度条啊等等，那么你就需要美化一下你的输出了。 除了颜色这部分，不使用第三方包实现起来非常繁琐复杂，其他的功能，都可以试试自己写。 颜色部分使用了第三方包colors，这里就不演示了。 其他都是由nodejs自带的readline模块实现的。 //index.js const readline = require('readline'); const unloadChar='-'; const loadedChar='='; const rl=readline.createInterface({ input: process.stdin, output: process.stdout }); rl.question('你想对谁说声hello？ ',answer=&gt;{ let i = 0; let time = setInterval(()=&gt;{ if(i&gt;10){ clearInterval(time); readline.cursorTo(process.stdout, 0, 0); readline.clearScreenDown(process.stdout); console.log(`hello ${answer}`); process.exit(0) return } readline.cursorTo(process.stdout,0,1); readline.clearScreenDown(process.stdout); renderProgress('saying hello',i); i++ },200); }); function renderProgress(text,step){ const PERCENT = Math.round(step*10); const COUNT = 2; const unloadStr = new Array(COUNT*(10-step)).fill(unloadChar).join(''); const loadedStr = new Array(COUNT*(step)).fill(loadedChar).join(''); process.stdout.write(`${text}:【${loadedStr}${unloadStr}|${PERCENT}%】`) } 1. 先，通过readline.createInterface方法创建一个interface类，这个类下面有一个方法.question，用这个方法在命令行上抛出一个问题，在第二个参数传入一个函数进行监听。一旦用户输入完毕敲下回车，就会触发回调函数。 2. 然后我们在回调函数里面写了个计时器，假装我们在处理某些事务。 3. 使用readline.cursorTo这个方法，可以改变命令行上的光标的位置。readline.cursorTo(process.stdout, 0, 0);是移动到第1列第1行上，readline.cursorTo(process.stdout, 0, 1);是移动到第1列第2行上。 4. 使用readline.clearScreenDown这个方法，是让命令行从当前行开始，到最后一行结束，将这两行之间所有内容清除。 5. renderProgress是自己封装的一个方法，通过process.stdout.write方法输出一行看起来像是进度条的字符串到命令行上。所以在计时器里面，当计数小于10的时候，我们让光标移到第一行上，然后清除所有输出，输出进度条字符串；当计数大于10的时候，我们关掉计时器，清除输出，打印结果。 6. 最后不要忘记关掉进程，可以使用interface这个类的.close方法关掉readline进程，也可以直接调用process.exit退出。 绘制的思路跟canvas绘制动画一样，只不过canvas是清除画布，而命令行这里是通过readline.clearScreenDown清除输出。 这样，一个简易的，人性化的，带点点进度条动画的命令行cli工具就写好了，你也可以发挥你的想象力，去写一些更有趣的效果出来。 毕竟我们前端，有浏览器我们可以写动画，没了浏览器我们一样可以写动画。 0x6 参考 http://www.ruanyifeng.com/blog/2015/05/command-line-with-node.html http://nodejs.cn/api/readline.html https://github.com/Marak/colors.js https://github.com/shelljs/shelljs 链接：https://www.jianshu.com/p/095c968d406f 作者：CharTen 来源：简书 ","link":"https://lingtin.github.io/post/dMvRzXo3O/"},{"title":"PowerShell因为在此系统中禁止执行脚本解决方法","content":"在Powershell直接脚本时会出现： 无法加载文件 ******.ps1，因为在此系统中禁止执行脚本。 有关详细信息，请参阅 &quot;get-help about_signing&quot;。 所在位置 行:1 字符: 17 + E:\\Test\\test.ps1 &lt;&lt;&lt;&lt; + CategoryInfo : NotSpecified: (:) [], PSSecurityException + FullyQualifiedErrorId : RuntimeException 查看“get-help about_signing”: 简短说明 说明如何对脚本进行签名以使其符合 Windows PowerShell 执行策略。 详细说明 Restricted 执行策略不允许任何脚本运行。 AllSigned 和 RemoteSigned 执行策略可防止 Windows PowerShell 运行没有数字签名的脚本。 本主题说明如何运行所选未签名脚本（即使在执行策略为 RemoteSigned 的情况下），还说明如何对 脚本进行签名以便您自己使用。 有关 Windows PowerShell 执行策略的详细信息，请参阅 about_Execution_Policy。 允许运行签名脚本 首次在计算机上启动 Windows PowerShell 时，现用执行策略很可能是 Restricted（默认设置）。 Restricted 策略不允许任何脚本运行。 若要了解计算机上的现用执行策略，请键入： get-executionpolicy **若要在本地计算机上运行您编写的未签名脚本和来自其他用户的签名脚本，请使用以下命令将计算机上的 执行策略更改为 RemoteSigned：** set-executionpolicy remotesigned 有关详细信息，请参阅 Set-ExecutionPolicy。 执行“set-ExecutionPolicy RemoteSigned ”： 执行策略更改 执行策略可以防止您执行不信任的脚本。更改执行策略可能会使您面临about_Execution_Policies 帮助主题中所述的安全风险。是否要更改执行策略? [Y] 是(Y) [N] 否(N) [S] 挂起(S) [?] 帮助 (默认值为“Y”): y ","link":"https://lingtin.github.io/post/SAWHkI2RW/"},{"title":"移动端css，rem布局方案","content":"规范只列举了rem布局这一种适配方式，但不是说限制只能用这种布局方式。 无论用何种方式，需要保证在不同比例、不同尺寸的手机上，测试微信、手Q、safari、UC等主流浏览器无明显错位、变形。 viewport &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot;&gt; 初始字号 css中设定html根元素的初始字体大小为100px html{font-size:100px;} 单位转换 不管你拿到的设计稿宽度是640px还是750px，多大都一样。和我们平时做PC页面的做法基本一样，只需要把单位px换算成rem，所有设计稿的的元素大小全除以100单位换成rem，例如设计稿上个某个文字的大小为30px，直接写font-size:0.3rem。 示例代码 用 onorientationchange 函数来检测屏幕旋转，在一些APP或游戏内嵌页面会有该函数不会执行、orientation获取不到的情况。所以如果是游戏app内嵌页建议使用 resize 事件，检查宽高变化来检测屏幕是否旋转。 &lt;script&gt; //屏幕适应 (function (win, doc) { if (!win.addEventListener) return; var html = document.documentElement; function setFont() { var html = document.documentElement; var k = 640; html.style.fontSize = html.clientWidth / k * 100 + &quot;px&quot;; } setFont(); setTimeout(function () { setFont(); }, 300); doc.addEventListener('DOMContentLoaded', setFont, false); win.addEventListener('resize', setFont, false); win.addEventListener('load', setFont, false); })(window, document); &lt;/script&gt; 注意事项 使用rem方式布局有以下几点需要注意： 页面用不同尺寸的手机进行测试 因为小于1px浏览器支持不够好为会导致计算会有误差，背景图使用雪碧图时，图标之间多留5px的空隙，同时图片的backgrornd-size属性最好写上图片的宽高，不写误差更大。 雪碧图，如图片宽高为346px*160px需要设置background-size属性设置为background-size: 3.46rem 1.6rem; 大小为1px的元素不要使用rem，直接用px 多栏多列布局优先使用百分比%或是display:flex ","link":"https://lingtin.github.io/post/IHuGtVGXh/"},{"title":"Javascript使用blob接收、下载文件","content":"我们知道，下载文件是一个非常常见的需求，但由于浏览器的安全策略的限制，我们通常只能通过一个额外的页面，访问某个文件的 url 来实现下载功能，但是这种用户体验非常不好。 幸好，HTML 5 里面为 &lt;a&gt; 标签添加了一个 download 的属性，我们可以轻易的利用它来实现下载功能，再也不需要用以前的笨办法了。 原理 我们先看看 download 的使用方法： &lt;a href=&quot;http://somehost/somefile.zip&quot; download=&quot;filename.zip&quot;&gt;Download file&lt;/a&gt; 看看上面的代码，只要为 &lt;a&gt; 标签添加 download 属性，我们点击这个链接的时候就会自动下载文件了~ 顺便说下，download 的属性值是可选的，它用来指定下载文件的文件名。像上面的例子中，我们下载到本地的文件名就会是 filename.zip 拉，如果不指定的话，它就会是 somefile.zip 这个名字拉！ 看到这里，你可能会说，坑爹啊，这明明是用 HTML 5 的新特性来实现下载文件嘛，说好的用 JavaScript 下载文件呢？ 事实上，用 JavaScript 来下载文件也是利用这一特性来实现的，我们的 JavaScript 代码不外乎就是： 用 JavaScript 创建一个隐藏的 &lt;a&gt; 标签 设置它的 href 属性 设置它的 download 属性 用 JavaScript 来触发这个它的 click 事件 翻译成 JavaScript 代码就是： var a = document.createElement('a'); var url = window.URL.createObjectURL(blob); var filename = 'what-you-want.txt'; a.href = url; a.download = filename; a.click(); window.URL.revokeObjectURL(url); 好拉，是不是看到有个陌生的东东呢？ window.URL window.URL 里面有两个方法： createObjectURL 用 blob 对象来创建一个 object URL(它是一个 DOMString)，我们可以用这个 object URL 来表示某个 blob 对象，这个 object URL 可以用在 href 和 src 之类的属性上。 revokeObjectURL 释放由 createObjectURL 创建的 object URL，当该 object URL 不需要的时候，我们要主动调用这个方法来获取最佳性能和内存使用。 知道了这两个方法之后，我们再回去看看上面的例子就很容易理解了吧！只是用 blob 对象来创建一条 URL，然后让 &lt;a&gt; 标签引用该 URL，然后触发个点击事件，就可以下载文件了！ 那么问题来了，blob 对象哪里来？ Blob 对象 Blob 全称是 Binary large object，它表示一个类文件对象，可以用它来表示一个文件。根据 MDN 上面的说法，File API 也是基于 blob 来实现的。 由于本文的主题是讲 JavaScript 下载文件，那我们构建 blob 的方式就是通过服务器返回的文件来创建 blob 拉！ 而最简单的方式就是用 fetch API 了，我们可以整合上面的例子： fetch('http://somehost/somefile.zip').then(res =&gt; res.blob().then(blob =&gt; { var a = document.createElement('a'); var url = window.URL.createObjectURL(blob); var filename = 'myfile.zip'; a.href = url; a.download = filename; a.click(); window.URL.revokeObjectURL(url); })) 很简单对吧！ 你可能会问，何必这么麻烦呢？直接写成下面这样不就好了： &lt;a href=&quot;http://somehost/somefile.zip&quot; download=&quot;myfile.zip&quot;&gt;Download file&lt;/a&gt; 嗯，对于这种写法，我只能说，你做的太正确了！如果你要下载的是已经存在服务器上面的静态文件的话，那么写成这样是最方便的。浏览器会帮你处理整个下载过程，不需要你干涉。如果你用 blob 的方式来下载文件的话，会有下面这些限制的： 限制一：不同浏览器对 blob 对象有不同的限制 具体看看下面这个表格（出自 FileSaver.js）： Browser Constructs as Filenames Max Blob Size Dependencies Firefox 20+ Blob Yes 800 MiB None Firefox &lt; 20 data: URI No n/a Blob.js Chrome Blob Yes 500 MiB None Chrome for Android Blob Yes 500 MiB None Edge Blob Yes ? None IE 10+ Blob Yes 600 MiB None Opera 15+ Blob Yes 500 MiB None Opera &lt; 15 data: URI No n/a Blob.js Safari 6.1+* Blob No ? None Safari &lt; 6 data: URI No n/a Blob.js 限制二：构建完 blob 对象后才会转换成文件 这一点限制对小文件(几十kb)可能没什么影响，但对稍微大一点的文件影响就很大了。试想，用户要下载一个 100mb 的文件，如果他点击了下载按钮之后没看到下载提示的话，他肯定会继续按，等他按了几次之后还没看到下载提示时，他就会抱怨我们的网站，然后离开了。 然而事实上下载的的确确发生了，只是要等到下载完文件之后才能构建 blob 对象，再转化成文件。而且，用户再触发多几次下载就会造成一些资源上的浪费。 因此，如果是要下载大文件的话，还是推荐直接创建一个 &lt;a&gt;标签拉~ 写 html 也好，写 JavaScript 动态创建也好，用自己喜欢的方式去创建就好了。 为什么要用 JavaScript 下载文件. 好拉，说了半天，其实我们一直说的都是：「不要用 JavaScript 下载文件拉，限制多多，又不好用，直接用 html 就好拉，简单方便又快捷」这个论调。 事实上也确实如此，但有些时候我们确实需要通过 JavaScript 来做一些预处理。 权限校验 有些时候，我们需要对下载做一些限制，最常见的就是权限校验了，如检查该用户是否有下载的权限，是否有高速下载的权限等等。这时候，我们可以利用 JavaScript 做一些预处理。如： fetch('http://somehost/check-permission', options).then(res =&gt; { if (res.code === 0) { var a = document.createElement('a'); var url = res.data.url; var filename = 'myfile.zip'; a.href = url; a.download = filename; a.click(); } else { alert('You have no permission to download the file!'); } }); 在这个例子里面，我们没有用 blob 来构建 URL，而是通过后端服务器来计算出用户的下载链接，然后再利用之前提到的动态创建 &lt;a&gt; 标签的方式来实现下载，很简单吧！ 动态文件 动态生成文件然后返回给客户端也是一个很常见的需求，譬如我们有时候需要做导出数据的功能，把数据库中的某些数据导出到 Excel 中，然后再返回客户端。 这时候我们就不能简单的指定 href 属性，因为对应的 URL 并不存在。 我们只能通过 JavaScript 对服务器发出一个请求，通知它去生成某个文件，然后把对应的 URL 返回给客户端。 有没有感觉这个过程和上面「权限校验」一节很像？肯定拉，因为我们只是对 URL 做了一些预处理而已嘛~ 注意事项 由于 download 属性是 HTML 5 的新特性，因此它不支持旧版本的浏览器。 总结 HTML 5 新的 download 特性真的很好用，结合 JavaScript 的动态能力我们可以很方便的做出复杂的下载功能~ 参考资料 https://github.com/eligrey/FileSaver.js/blob/master/FileSaver.js https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL https://developer.mozilla.org/en-US/docs/Web/API/Blob http://stackoverflow.com/questions/19327749/javascript-blob-filename-without-link http://stackoverflow.com/questions/24501358/how-to-set-a-header-for-a-http-get-request-and-trigger-file-download http://blog.bguiz.com/2014/07/03/file-download-with-http-request-header/ ","link":"https://lingtin.github.io/post/sdgGjZQiN/"},{"title":"使用Vue和GraphQL构建一个CRUD APP","content":"本文提供了使用 Vue 和 GraphQL 构建一个 CRUD APP 的详细步骤，展示了如何安装 Apollo， 如何将它与 Vue.js 集成，以及如何发送查询和修改来读取、创建、更新和删除数据库中的数据。 在本教程中，我们将学习使用 Vue 和 GraphQL 构建一个 CRUD APP。CRUD 是指该 APP 中所包含的创建、读取、更新和删除操作。你可以在 GitHub 上找到这个演示的源代码： https://github.com/JscramblerBlog/vue-graphql-demo 准备工作 本教程首先需要几项准备工作： 在你的开发的机器上安装 Node.js 和 NPM。你可以从官方网站 下载它们，或者在你的系统中使用 NVM 轻松安装 Node.js。 具备 JavaScript 的知识，熟悉 Vue。 有 GraphQL Server 相关经验。 如果你已经做好这些准备工作，那就让我们一起开始吧。 在服务器中启用 CORS 由于我们在两个不同的本地端口之间发送请求，这两个端口被视为两个独立的域，因此我们需要在服务器中启用跨源资源共享功能（Cross-Origin Resource Sharing，CORS）： https://blog.jscrambler.com/understanding-cors-cross-origin-resource-sharing/ 首先，从 GitHub 库中把代码克隆出来： git clone https://github.com/JscramblerBlog/node-express-graphql-api.git 接着，进入你的项目目录，安装以下相关组件和 cors 模块： cd node-express-graphql-api npm install npm install cors --save 然后打开 index.js 文件，导入 cors 模块： const cors = require('cors'); 接下来，将 cors 中间件添加到 Express app 中： const app = express(); app.use(cors()) 最后，启动服务器： node index.js 这样你的 GraphQL 服务器就运行起来了，可以在http://localhost:4000/地址下访问。 安装 Vue CLI 3 我们需要安装 Vue CLI 来快速生成 Vue 项目并使用这些项目。打开一个新终端并运行以下命令： npm install -g @vue/cli 在看完这几个字的时间里，你的机器上应该已经完成 @vue/cli v3.8.2的安装了。 创建一个 Vue 项目 使用 Vue CLI，让我们继续创建一个 Vue 项目。回到终端机，执行下列命令： vue create vue-graphql-demo 当提示对预置选项进行选择时，你可以简单地选择默认设置。 等待生成项目，运行以下命令启动开发服务器： cd vue-graphql-demo npm run serve 这样，你的应用就运行起来了，在 http://localhost:8080/地址下可以访问。 安装 Apollo 客户端 Apollo 是一组实用程序，可以帮助你在 APP 中使用 GraphQL。它以其客户端和服务器而闻名。Apollo 是由 Meteor Development Group开发和维护的：https://www.meteor.io/ 打开一个新的终端，进入你的项目文件夹，运行以下命令来安装 Apollo 客户端到你的 Vue 项目中： npm install --save vue-apollo graphql apollo-boost Apollo Boost 是一种无需任何手动配置就可以开始使用 Apollo 客户端的方式。它包括一些常见的默认值，比如推荐的 InMemoryCache和HttpLink，它们是以推荐的参数为你进行配置的。这种零配置的方式适合快速开发使用。 在 src/main.js 文件中，添加以下代码来创建 Apollo 客户端的实例，并将其连接到运行于 http://localhost:4000/graphql 的 GraphQL 服务器： import ApolloClient from &quot;apollo-boost&quot; import VueApollo from &quot;vue-apollo&quot; const apolloClient = new ApolloClient({ uri: &quot;http://localhost:4000/graphql&quot; }) Vue.use(VueApollo) const apolloProvider = new VueApollo({ defaultClient: apolloClient, }) 我们从 apollo-boost 包中导入 Apollo 客户端 ，从 vue-apollo 包中导入 VueApollo。接下来，我们需要创建 Apollo 客户端的一个实例，并传入 GraphQL 端点的 URL。 然后，我们使用 VueApollo 插件将 Apollo 集成到我们的 Vue APP 中。 最后，我们创建了 Apollo Provider，它包含所有 Vue 组件都可以使用的 Apollo Client 实例。 我们现在要做的就是用 apolloProvider 选项将 Apollo Provider 添加到 Vue 实例中： new Vue({ render: h =&gt; h(App), apolloProvider, }).$mount('#app') 这样就行了。现在，我们准备在 Vue APP 中使用 Apollo 客户端。 更多信息请参见文档： https://vue-apollo.netlify.com/guide/installation.html#manual-installation 使用 GraphQL API 将 vue-apollo 添加到 APP 后，所有组件都可以通过 apollo 选项来使用 Apollo。 首先，打开 src/App.vue 组件，并将 data() 函数添加到具有以下变量的导出对象中： &lt;script&gt; export default { name: 'app', data(){ return { id: null, firstName: '', lastName: '', email: ''} } 我们定义了四个组件变量，分别是 id、firstName、lastName 和 email。这些变量将被绑定到用于创建新联系人的 HTML Form 中。 发送一个 GraphQL 查询来读取数据 接着，从 graphql-tag 包中导入 gql，并将 apollo 对象添加到带有查询的组件中，我们将使用这个查询从 GraphQL API 中读取联系人： &lt;script&gt; import gql from 'graphql-tag' export default { name: 'app', /* [...] */ apollo: { contacts: gql`query { contacts { id, firstName, lastName, email } }`, }, gql 是一个 JavaScript 模板文字标签，它将 GraphQL 查询字符串解析到标准的 GraphQL AST 中。可以在 Github 上的官方库中找到更多详细信息： https://github.com/apollographql/graphql-tag 在这个 apollo 对象中，我们添加了一个 contacts 属性，它将保存 contacts 查询的结果。稍后，我们将使用它在模板中显示联系人。 发送用于CRUD数据的 mutation 查询 接下来，添加 createContact()、updateContact() 和 deleteContact() 三个方法如下： methods: { createContact(firstName, lastName, email){ console.log(`Create contact: ${email}`) this.$apollo.mutate({ mutation: gql`mutation createContact($firstName: String!, $lastName: String!, $email: String!){ createContact(firstName: $firstName, lastName: $lastName, email: $email) { id, firstName, lastName, email} }`, variables:{ firstName: firstName, lastName: lastName, email: email } } ) location.reload(); }, updateContact(id, firstName, lastName, email){ console.log(`Update contact: # ${id}`) this.$apollo.mutate({ mutation: gql`mutation updateContact($id: ID!, $firstName: String!, $lastName: String!, $email: String!){ updateContact(id: $id, firstName: $firstName, lastName: $lastName, email: $email) `, variables:{ id: id, firstName: firstName, lastName: lastName, email: email } } ) location.reload(); }, deleteContact(id){ console.log(`Delete contact: # ${id}`) this.$apollo.mutate({ mutation: gql`mutation deleteContact($id: ID!){ deleteContact(id: $id) }`, variables:{ id: id, } } ) location.reload(); }, } 在这三个方法中，我们使用 this.$apollo.mutate() 方法向 GraphQL Server 发送 mutation 查询，并调用 location.reload() 方法来重新加载页面。 有关发送 mutation 查询的更多信息，请 参阅文档。 接下来，在 methods 对象中添加 selectContact() 和 clearForm() 方法： selectContact(contact){ this.id = contact.id; this.firstName = contact.firstName; this.lastName = contact.lastName; this.email = contact.email; }, clearForm(){ this.id = null; this.firstName = ''; this.lastName = ''; this.email = ''; } 这两个方法被用来从 Table 中选择一个联系人放入 Form，以及清空 Form。 添加模板 现在让我们添加一个 Table 和 Form 来显示、创建、更新和删除联系人。让我们从 HTML Table 开始： &lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;table border='1' width='100%' style='border-collapse: collapse;'&gt; &lt;tr&gt; &lt;th&gt;First Name&lt;/th&gt; &lt;th&gt;Last Name&lt;/th&gt; &lt;th&gt;Email&lt;/th&gt; &lt;th&gt;Actions&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for='contact in contacts'&gt; &lt;td&gt;{{ contact.firstName }}&lt;/td&gt; &lt;td&gt;{{ contact.lastName }}&lt;/td&gt; &lt;td&gt;{{ contact.email }}&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;button&quot; @click=&quot;selectContact(contact)&quot; value=&quot;Select&quot;&gt; &lt;input type=&quot;button&quot; @click=&quot;deleteContact(contact.id)&quot; value=&quot;Delete&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 我们使用 v-for 指令来迭代 Apollo 对象的 contacts 属性，该 Apollo 对象包含从服务器获取的联系人。我们还添加了两个按钮来选择和删除相应的联系人。 接下来，我们将 Form 添加到 Table 里： &lt;/br&gt; &lt;form&gt; &lt;label&gt;First Name&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;firstName&quot; v-model=&quot;firstName&quot;&gt; &lt;/br&gt; &lt;label&gt;Last Name&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;lastName&quot; v-model=&quot;lastName&quot;&gt; &lt;/br&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input type=&quot;email&quot; name=&quot;email&quot; v-model=&quot;email&quot;&gt; &lt;/br&gt; &lt;input v-if=&quot;!id&quot; type=&quot;button&quot; @click=&quot;createContact(firstName, lastName, email)&quot; value=&quot;Add&quot;&gt; &lt;input v-if=&quot;id&quot; type=&quot;button&quot; @click=&quot;updateContact(id, firstName, lastName, email)&quot; value=&quot;Update&quot;&gt; &lt;input type=&quot;button&quot; @click=&quot;clearForm()&quot; value=&quot;Clear&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;/template&gt; 我们这样就创建了 Form，每个 Form 包含三个输入，它们绑定到组件中声明的 firstName、lastName 和 email 变量。我们还添加了三个按钮，用于创建新联系人、更新选定的联系人和清除该 Form。 这是添加了大量数据后 UI 的截图： 使用 Select 按钮选择联系人后，将载入 Form 内容，这时会出现 Update 按钮，而不是 Add 按钮： 结论 在本教程中，我们学习了如何用 Apollo 客户端来调用 GraphQL API。我们已经了解了如何安装 Apollo，如何将它与 Vue.js 集成，以及如何发送查询和修改来读取、创建、更新和删除数据库中的联系人。 如果你正在构建具有敏感逻辑的 Vue APP，请遵循我们的指南，以保证它们不受代码盗窃和逆向工程的影响： https://blog.jscrambler.com/how-to-protect-your-vue-js-application-with-jscrambler/ 文章来源： https://mp.weixin.qq.com 英文原文： https://blog.jscrambler.com/building-a-crud-app-with-vue-and-graphql/?utm_source=echojs.com&amp;utm_medium=referral ","link":"https://lingtin.github.io/post/nMCipG_qg/"},{"title":"提升90%加载速度——vuecli下的首屏性能优化","content":"1、~分析工具 2、路由懒加载 之前用 vuecli做了个博客，是一个单页面项目，大概有十个路由 直接 npm run build打包出来，有一个 1M的巨大 js文件 先挂载到服务器上试试 好家伙 这加载时间 仿佛过了半个世纪 首屏页面整整加载了 9s 光加载那个大文件就花了 8s 这必须得做个优化了，没有用户能忍受 9s的白屏而不关闭页面的 过程中，我还顺便把项目从 vuecli 2.x迁移到了 vuecli 3，所以接下来还会介绍一些它们在优化上的异同 ~分析 vuecli 2.x自带了分析工具 只要运行 npm run build --report 如果是 vuecli 3的话，先安装插件 npm install webpack-bundle-analyzer --save -dev 然后在 vue.config.js中对 webpack进行配置 chainWebpack: (config) =&gt; { /* 添加分析工具*/ if(process.env.NODE_ENV ==='production'){ if(process.env.npm_config_report){ config.plugin('webpack-bundle-analyzer') .use(require('webpack-bundle-analyzer').BundleAnalyzerPlugin).end(); config. plugins.delete('prefetch') } } } 再运行 npm run build --report 会在浏览器打开一个项目打包的情况图，便于直观地比较各个 bundle文件的大小 可以看到 项目中所有的依赖，所有的路由，都被打包进了同一个文件中 另外，在浏览器中，也可以通过 converge来查看代码的使用状况 红色的是下载了但未使用的部分 路由懒加载 当打包构建应用时，JavaScript包会变得非常大，影响页面加载。 如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。 在一开始就下载完所有路由对应的组件文件，这明显是不合适的，这就像下载一个 app了，所以我们就需要使用路由懒加载 在 router.js文件中，原来的静态引用方式 import ShowBlogs from'@/components/ShowBlogs' routes :[path :'Blogs', name :'ShowBlogs', component : ShowBlogs] 改为 routes :[path :'Blogs', name :'ShowBlogs', component : ()=&gt; import ('./components/ShowBlogs.vue') 以函数的形式动态引入，这样就可以把各自的路由文件分别打包，只有在解析给定的路由时，才会下载路由组件 首屏需要加载的文件变成了橙色的部分，被小弟们分流出去了 300k 如果是在 vuecli 3中，我们还需要多做一步工作 因为 vuecli 3默认开启 prefetch(预先加载模块)，提前获取用户未来可能会访问的内容 在首屏会把这十几个路由文件，都一口气下载了 所以我们要关闭这个功能，在 vue.config.js中设置 参考官网的做法： // vue.config.js module.exports = { chainWebpack: config =&gt; { // 移除 prefetch 插件 config.plugins.delete('prefetch') // 或者 // 修改它的选项： config.plugin('prefetch').tap(options =&gt; { options[0].fileBlacklist = options[0].fileBlacklist || [] options[0].fileBlacklist.push(/myasyncRoute(.)+?\\.js$/) return options }) } } 当 prefetch 插件被禁用时，你可以通过 webpack 的内联注释手动选定要提前获取的代码区块： import(/* webpackPrefetch: true */ './someAsyncComponent.vue') webpack 的运行时会在父级区块被加载之后注入 prefetch 链接。 详情查看：https://cli.vuejs.org/zh/guide/html-and-static-assets.html#prefetch 设置完毕后，首屏就只会加载当前页面路由的组件了 ~ui按需加载 首屏需要加载的依赖包，其中 ui整整占了 568k 原本的引进方式引进了整个包： import ElementUI from'element-ui' Vue . use (ElementUI) 但实际上我用到的组件只有按钮，分页，表格，输入与警告 所以我们要按需引用： import { Button, Input, Pagination, Table, TableColumn, MessageBox } from'element-ui'; Vue . use (Button) Vue . use (Input) Vue . use (Pagination) Vue . prototype . $alert=MessageBox . alert 注意 MessageBox注册方法的区别，并且我们虽然用到了 alert，但并不需要引入 Alert组件 在.babelrc文件中添加（vue-cli 3要先安装 babel-plugin-component)： plugins :[[&quot;component&quot;, { &quot;libraryName&quot; :&quot;element-ui&quot;, &quot;styleLibraryName&quot; :&quot;theme-chalk&quot; } ]] import { Table, TableColumn } from&quot;element-ui&quot;; components : { &quot;el-table&quot; : Table, &quot;el-table-column&quot; : TableColumn }, table就被拆分到了路由文件中 ~组件重复打包 可以看到上图，有两个路由文件都引用了 codemirror.js造成重复下载 我们可以在webpack的 config文件中，修改CommonsChunkPlugin的配置 minChunks : 3 把3改为2，就会把使用2次及以上的包抽离出来，放进公共依赖文件，不过由于首页也有复用的组件，所以首页也会下载这个公共依赖文件 首页下载了黄色和灰色部分 拆了半天，又回到原点 当然，我们可以继续折腾 CommonsChunkPlugin的配置来解决这个问题 但在新版 webpack中，CommonsChunkPlugin被自由度更高，更高级的 SplitChunksPlugin代替 这也是为什么我要把项目迁移到 vuecli 3（使用 webpack4） 默认就做了优化，首页只会下载灰色的部分（ 235K） ~gzip 拆完包之后，我们再用 gzip做一下压缩 安装compression-webpack-plugin npm i compression-webpack-plugin -dev 在 vue.congig.js中引入并修改webpack配置 const CompressionPlugin=require ('compression-webpack-plugin') configureWebpack: (config) =&gt; { if (process.env.NODE_ENV === 'production') { // 为生产环境修改配置... config.mode = 'production'; return { plugins: [new CompressionPlugin({ test: /\\.js$|\\.html$|\\.css/, //匹配文件名 threshold: 10240, //对超过10k的数据进行压缩 deleteOriginalAssets: false //是否删除原文件 })] } } } 可以看到 200k以上的文件被压缩到了 100k以内 在服务器我们也要做相应的配置 如果发送请求的浏览器支持 gzip，就发送给它 gzip格式的文件 我的服务器是用 express框架搭建的 只要安装一下 compression就能使用 const compression=require ('compression') app . use (compression ()) 注意，后面这一句，要放在所有其他中间件注册之前 ~最终效果 首屏加载资源198k，加载时间1s，相比原来速度提升了90% ~后记：css是否要拆分 vuecli 3和 vuecli2.x还有一个区别是 vuecli 3会默认开启一个 css分离插件 ExtractTextPlugin 每一个模块的 css文件都会分离出来，整整13个 css文件，而我们的首页就请求了4个，花费了不少的资源请求时间 我们可以在vue.config.js中关闭它 css : { // 是否使用css分离插件 ExtractTextPlugin extract : false, // 开启 CSS source maps? sourceMap : false, // css预设器配置项 loaderOptions : { } , // 启用 CSS modules for all css / pre-processor files. modules : false }, 打包出来的文件中，直接就没有了 css文件夹 取而代之的是整合起来的一个 js文件，负责在一开始就注入所有的样式 首屏加载文件数减少，但体积变大，最终测下来速度没有太大差异 所以，是否要css拆分就见仁见智，具体项目具体分析吧 ~总结 性能优化是一个非常令人愉悦的过程，同时也是个深坑，有着太多东西，本篇文章开了个头，希望能对大家有所帮助 参考资料： Vue打包优化之code spliting https://juejin.im/post/5ac815... Vue 性能优化：如何实现延迟加载和代码拆分？ https://www.infoq.cn/article/...*zN Webpack 打包优化之体积篇 https://www.jeffjade.com/2017... 记一次vue+element+echarts项目的优化 https://juejin.im/post/5b0033... 来源：https://segmentfault.com/a/1190000019499007 ","link":"https://lingtin.github.io/post/91m5xw25V/"},{"title":"NPM Scripts 指南","content":"Node 开发离不开 npm，而脚本功能是 npm 最强大、最常用的功能之一。 本文介绍如何使用 npm 脚本（npm scripts）。 转载自：http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html 一、什么是 npm 脚本？ npm 允许在package.json文件里面，使用scripts字段定义脚本命令。 { // ... &quot;scripts&quot;: { &quot;build&quot;: &quot;node build.js&quot; } } 上面代码是package.json文件的一个片段，里面的scripts字段是一个对象。它的每一个属性，对应一段脚本。比如，build命令对应的脚本是node build.js。 命令行下使用npm run命令，就可以执行这段脚本。 $ npm run build 等同于执行 $ node build.js 这些定义在package.json里面的脚本，就称为 npm 脚本。它的优点很多。 项目的相关脚本，可以集中在一个地方。 不同项目的脚本命令，只要功能相同，就可以有同样的对外接口。用户不需要知道怎么测试你的项目，只要运行npm run test即可。 可以利用 npm 提供的很多辅助功能。 查看当前项目的所有 npm 脚本命令，可以使用不带任何参数的npm run命令。 $ npm run 二、原理 npm 脚本的原理非常简单。每当执行npm run，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。 比较特别的是，npm run新建的这个 Shell，会将当前目录的node_modules/.bin子目录加入PATH变量，执行结束后，再将PATH变量恢复原样。 这意味着，当前目录的node_modules/.bin子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。比如，当前项目的依赖里面有 Mocha，只要直接写mocha test就可以了。 &quot;test&quot;: &quot;mocha test&quot; 而不用写成下面这样。 &quot;test&quot;: &quot;./node_modules/.bin/mocha test&quot; 由于 npm 脚本的唯一要求就是可以在 Shell 执行，因此它不一定是 Node 脚本，任何可执行文件都可以写在里面。 npm 脚本的退出码，也遵守 Shell 脚本规则。如果退出码不是0，npm 就认为这个脚本执行失败。 三、通配符 由于 npm 脚本就是 Shell 脚本，因为可以使用 Shell 通配符。 &quot;lint&quot;: &quot;jshint *.js&quot; &quot;lint&quot;: &quot;jshint **/*.js&quot; 上面代码中，* 表示任意文件名，** 表示任意一层子目录。 如果要将通配符传入原始命令，防止被 Shell 转义，要将星号转义。 &quot;test&quot;: &quot;tap test/\\*.js&quot; 四、传参 向 npm 脚本传入参数，要使用--标明。 &quot;lint&quot;: &quot;jshint **.js&quot; 向上面的npm run lint命令传入参数，必须写成下面这样。 $ npm run lint -- --reporter checkstyle &gt; checkstyle.xml 也可以在package.json里面再封装一个命令。 &quot;lint&quot;: &quot;jshint **.js&quot;, &quot;lint:checkstyle&quot;: &quot;npm run lint -- --reporter checkstyle &gt; checkstyle.xml&quot; 五、执行顺序 如果 npm 脚本里面需要执行多个任务，那么需要明确它们的执行顺序。 如果是并行执行（即同时的平行执行），可以使用&amp;符号。 $ npm run script1.js &amp; npm run script2.js 如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用&amp;&amp;符号。 $ npm run script1.js &amp;&amp; npm run script2.js 这两个符号是 Bash 的功能。此外，还可以使用 node 的任务管理模块：script-runner、npm-run-all、redrun。 六、默认值 一般来说，npm 脚本由用户提供。但是，npm 对两个脚本提供了默认值。也就是说，这两个脚本不用定义，就可以直接使用。 &quot;start&quot;: &quot;node server.js&quot;， &quot;install&quot;: &quot;node-gyp rebuild&quot; 上面代码中，npm run start的默认值是node server.js，前提是项目根目录下有server.js这个脚本； npm run install的默认值是node-gyp rebuild，前提是项目根目录下有binding.gyp文件。 七、钩子 npm 脚本有pre和post两个钩子。举例来说，build脚本命令的钩子就是prebuild和postbuild。 &quot;prebuild&quot;: &quot;echo I run before the build script&quot;, &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack&quot;, &quot;postbuild&quot;: &quot;echo I run after the build script&quot; 用户执行npm run build的时候，会自动按照下面的顺序执行。 npm run prebuild &amp;&amp; npm run build &amp;&amp; npm run postbuild 因此，可以在这两个钩子里面，完成一些准备工作和清理工作。下面是一个例子。 &quot;clean&quot;: &quot;rimraf ./dist &amp;&amp; mkdir dist&quot;, &quot;prebuild&quot;: &quot;npm run clean&quot;, &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack&quot; npm 默认提供下面这些钩子。 prepublish，postpublish preinstall，postinstall preuninstall，postuninstall preversion，postversion pretest，posttest prestop，poststop prestart，poststart prerestart，postrestart 自定义的脚本命令也可以加上pre和post钩子。比如，myscript这个脚本命令，也有premyscript和postmyscript钩子。不过，双重的pre和post无效，比如prepretest和postposttest是无效的。 npm 提供一个npm_lifecycle_event变量，返回当前正在运行的脚本名称，比如pretest、test、posttest等等。所以，可以利用这个变量，在同一个脚本文件里面，为不同的npm scripts命令编写代码。请看下面的例子。 const TARGET = process.env.npm_lifecycle_event; if (TARGET === 'test') { console.log(`Running the test task!`); } if (TARGET === 'pretest') { console.log(`Running the pretest task!`); } if (TARGET === 'posttest') { console.log(`Running the posttest task!`); } 注意，prepublish这个钩子不仅会在npm publish命令之前运行，还会在npm install（不带任何参数）命令之前运行。这种行为很容易让用户感到困惑，所以 npm 4 引入了一个新的钩子prepare，行为等同于prepublish，而从 npm 5 开始，prepublish将只在npm publish命令之前运行。 八、简写形式 四个常用的 npm 脚本有简写形式。 npm start是npm run start npm stop是npm run stop的简写 npm test是npm run test的简写 npm restart是npm run stop &amp;&amp; npm run restart &amp;&amp; npm run start的简写 npm start、npm stop和npm restart都比较好理解，而npm restart是一个复合命令，实际上会执行三个脚本命令：stop、restart、start。具体的执行顺序如下。 prerestart prestop stop poststop restart prestart start poststart postrestart 九、变量 npm 脚本有一个非常强大的功能，就是可以使用 npm 的内部变量。 首先，通过npm_package_前缀，npm 脚本可以拿到package.json里面的字段。比如，下面是一个package.json。 { &quot;name&quot;: &quot;foo&quot;, &quot;version&quot;: &quot;1.2.5&quot;, &quot;scripts&quot;: { &quot;view&quot;: &quot;node view.js&quot; } } 那么，变量npm_package_name返回foo，变量npm_package_version返回1.2.5。 // view.js console.log(process.env.npm_package_name); // foo console.log(process.env.npm_package_version); // 1.2.5 上面代码中，我们通过环境变量process.env对象，拿到package.json的字段值。如果是 Bash 脚本，可以用npmpackagename和npm_package_name和npmp​ackagen​ame和npm_package_version取到这两个值。 npm_package_前缀也支持嵌套的package.json字段。 &quot;repository&quot;: { &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;xxx&quot; }, scripts: { &quot;view&quot;: &quot;echo $npm_package_repository_type&quot; } 上面代码中，repository字段的type属性，可以通过npm_package_repository_type取到。 下面是另外一个例子。 &quot;scripts&quot;: { &quot;install&quot;: &quot;foo.js&quot; } 上面代码中，npm_package_scripts_install变量的值等于foo.js。 然后，npm 脚本还可以通过npm_config_前缀，拿到 npm 的配置变量，即npm config get xxx命令返回的值。比如，当前模块的发行标签，可以通过npm_config_tag取到。 &quot;view&quot;: &quot;echo $npm_config_tag&quot;, 注意，package.json里面的config对象，可以被环境变量覆盖。 { &quot;name&quot; : &quot;foo&quot;, &quot;config&quot; : { &quot;port&quot; : &quot;8080&quot; }, &quot;scripts&quot; : { &quot;start&quot; : &quot;node server.js&quot; } } 上面代码中，npm_package_config_port变量返回的是8080。这个值可以用下面的方法覆盖。 $ npm config set foo:port 80 最后，env命令可以列出所有环境变量。 &quot;env&quot;: &quot;env&quot; 十、常用脚本示例 // 删除目录 &quot;clean&quot;: &quot;rimraf dist/*&quot;, // 本地搭建一个 HTTP 服务 &quot;serve&quot;: &quot;http-server -p 9090 dist/&quot;, // 打开浏览器 &quot;open:dev&quot;: &quot;opener http://localhost:9090&quot;, // 实时刷新 &quot;livereload&quot;: &quot;live-reload --port 9091 dist/&quot;, // 构建 HTML 文件 &quot;build:html&quot;: &quot;jade index.jade &gt; dist/index.html&quot;, // 只要 CSS 文件有变动，就重新执行构建 &quot;watch:css&quot;: &quot;watch 'npm run build:css' assets/styles/&quot;, // 只要 HTML 文件有变动，就重新执行构建 &quot;watch:html&quot;: &quot;watch 'npm run build:html' assets/html&quot;, // 部署到 Amazon S3 &quot;deploy:prod&quot;: &quot;s3-cli sync ./dist/ s3://example-com/prod-site/&quot;, // 构建 favicon &quot;build:favicon&quot;: &quot;node scripts/favicon.js&quot;, ","link":"https://lingtin.github.io/post/dwFY5Qi4D/"},{"title":"NodeJS进程管理器pm2","content":"pm2是一个带有负载均衡功能的Node应用的进程管理器。当你要把你的独立代码利用全部的服务器上的所有CPU，并保证进程永远都活着，0秒的重载， PM2是完美的。 pm2是开源的基于Nodejs的进程管理器，包括守护进程，监控，日志的一整套完整的功能，基本是Nodejs应用程序不二的守护进程选择，事实上它并不仅仅可以启动Nodejs的程序，只要是一般的脚本的程序它同样可以胜任。 ~、 主要特性： 内建负载均衡（使用Node cluster 集群模块） 后台运行 0秒停机重载（这项功能允许你重新载入代码而不用失去请求连接。） 具有Ubuntu和CentOS 的启动脚本 停止不稳定的进程（避免无限循环） 控制台检测 提供 HTTP API 远程控制和实时的接口API ( Nodejs 模块,允许和PM2进程管理器交互 ) ~、 使用环境： 仅能用于web应用 运行于Node 0.11.x版本 运行于 cluster 模式（默认模式） ~、 安装 npm install -g pm2 pm2安装好后，会自动创建下面目录： /.pm2 /.pm2/logs /.pm2/pids /.pm2/pm2.log /.pm2/pm2.pid /.pm2/rpc.sock /.pm2/pub.sock /.pm2/conf.js ~、用法 npm install pm2 -g # 命令行安装 pm2 pm2 start app.js -i 4 #后台运行pm2，启动4个app.js # 也可以把'max' 参数传递给 start # 正确的进程数目依赖于Cpu的核心数目 pm2 start app.js --name my-api # 命名进程 pm2 list # 显示所有进程状态 pm2 monit # 监视所有进程 pm2 logs # 显示所有进程日志 pm2 stop all # 停止所有进程 pm2 restart all # 重启所有进程 pm2 reload all # 0秒停机重载进程 (用于 NETWORKED 进程) pm2 stop 0 # 停止指定的进程 pm2 restart 0 # 重启指定的进程 pm2 startup # 产生 init 脚本 保持进程活着 pm2 web # 运行健壮的 computer API endpoint (http://localhost:9615) pm2 delete 0 # 杀死指定的进程 pm2 delete all # 杀死全部进程 运行进程的不同方式： $ pm2 start app.js -i max # 根据有效CPU数目启动最大进程数目 $ pm2 start app.js -i 3 # 启动3个进程 $ pm2 start app.js -x #用fork模式启动 app.js 而不是使用 cluster $ pm2 start app.js -x -- -a 23 # 用fork模式启动 app.js 并且传递参数 (-a 23) $ pm2 start app.js --name serverone # 启动一个进程并把它命名为 serverone $ pm2 stop serverone # 停止 serverone 进程 $ pm2 start app.json # 启动进程, 在 app.json里设置选项 $ pm2 start app.js -i max -- -a 23 #在--之后给 app.js 传递参数 $ pm2 start app.js -i max -e err.log -o out.log # 启动 并 生成一个配置文件 你也可以执行用其他语言编写的app ( fork 模式): $ pm2 start my-bash-script.sh -x --interpreter bash $ pm2 start my-python-script.py -x --interpreter python pm2 list 列出由pm2管理的所有进程信息，还会显示一个进程会被启动多少次，因为没处理的异常。 pm2 monit 监视每个node进程的CPU和内存的使用情况。 ~、入门教程 挑我们最爱的express应用来举例。一般我们都是通过npm start启动应用，其实就是调用node ./bin/www。那么，换成pm2就是 pm2 start ./bin/www –watch 这里用了–watch参数，意味着当你的express应用代码发生变化时，pm2会帮你重启服务。 ~、参数说明： --watch：监听应用目录的变化，一旦发生变化，自动重启。如果要精确监听、不见听的目录，最好通过配置文件。 -i --instances：启用多少个实例，可用于负载均衡。如果-i 0或者-i max，则根据当前机器核数确定实例数目。 --ignore-watch：排除监听的目录/文件，可以是特定的文件名，也可以是正则。比如--ignore-watch=&quot;test node_modules &quot;some scripts&quot;&quot; -n --name：应用的名称。查看应用信息的时候可以用到。 -o --output &lt;path&gt;：标准输出日志文件的路径。 -e --error &lt;path&gt;：错误输出日志文件的路径。 --interpreter &lt;interpreter&gt;：the interpreter pm2 should use for executing app (bash, python...)。比如你用的coffee script来编写应用。 完整命令行参数列表： pm2 start app.js –watch -i 2 **配置文件 ** 配置文件里的设置项，跟命令行参数基本是一一对应的。 可以选择js或者json文件，就看个人洗好了。 json格式的配置文件，pm2当作普通的js文件来处理，所以可以在里面添加注释或者编写代码，这对于动态调整配置很有好处。 如果启动的时候指定了配置文件，那么命令行参数会被忽略。（个别参数除外，比如--env） 举个简单例子： { &quot;name&quot; : &quot;fis-receiver&quot;, // 应用名称 &quot;script&quot; : &quot;./bin/www&quot;, // 实际启动脚本 &quot;cwd&quot; : &quot;./&quot;, // 当前工作路径 &quot;watch&quot;: [ // 监控变化的目录，一旦变化，自动重启 &quot;bin&quot;, &quot;routers&quot; ], &quot;ignore_watch&quot; : [ // 从监控目录中排除 &quot;node_modules&quot;, &quot;logs&quot;, &quot;public&quot; ], &quot;watch_options&quot;: { &quot;followSymlinks&quot;: false }, &quot;error_file&quot; : &quot;./logs/app-err.log&quot;, // 错误日志路径 &quot;out_file&quot; : &quot;./logs/app-out.log&quot;, // 普通日志路径 &quot;env&quot;: { &quot;NODE_ENV&quot;: &quot;production&quot; // 环境变量，object类型，如{&quot;NODE_ENV&quot;:&quot;production&quot;, &quot;ID&quot;: &quot;42&quot;}； }, &quot;instances&quot; : &quot;max&quot;, // 开启进程数，可为数值，也可为max。与服务器cpu核数相关。应用启动实例个数，仅在cluster模式有效，默认为fork； &quot;exec_mode&quot; : &quot;cluster&quot; // 应用启动模式，支持fork和cluster模式；cluster(多核推荐) &quot;min_uptime&quot;: &quot;60s&quot;, // 应用运行少于时间被认为是异常启动； &quot;max_restarts&quot;: 30, // 最大异常重启次数，即小于min_uptime运行时间重启次数； &quot;max_memory_restart&quot;: &quot;300M&quot;, // 最大内存限制数，超出自动重启； &quot;autorestart&quot;: true, // 默认为true, 发生异常的情况下自动重启； } pm2启动文件， pm2 init 创建一个ecosystem.config.js的示例文件，格式如下： module.exports = { &quot;apps&quot;:[ { &quot;name&quot;: &quot;test&quot;, &quot;cwd&quot;: &quot;/data/wwwroot/nodejs&quot;, &quot;script&quot;: &quot;./test.sh&quot;, &quot;exec_interpreter&quot;: &quot;bash&quot;, &quot;min_uptime&quot;: &quot;60s&quot;, &quot;max_restarts&quot;: 30, &quot;exec_mode&quot; : &quot;cluster_mode&quot;, &quot;error_file&quot; : &quot;./test-err.log&quot;, &quot;out_file&quot;: &quot;./test-out.log&quot;, &quot;pid_file&quot;: &quot;./test.pid&quot; &quot;watch&quot;: false } ]} ~、参数说明： apps：json结构，apps是一个数组，每一个数组成员就是对应一个pm2中运行的应用 name：应用程序的名称 cwd：应用程序所在的目录 script：应用程序的脚本路径 exec_interpreter：应用程序的脚本类型，这里使用的shell，默认是nodejs min_uptime：最小运行时间，这里设置的是60s即如果应用程序在60s内退出，pm2会认为程序异常退出，此时触发重启max_restarts设置数量 autorestart 默认为true, 发生异常的情况下自动重启； max_restarts：设置应用程序异常退出重启的次数，默认15次（从0开始计数） exec_mode：应用程序启动模式，这里设置的是cluster（集群），默认是fork error_file：自定义应用程序的错误日志文件 out_file：自定义应用程序日志文件 pid_file：自定义应用程序的pid文件 watch：是否启用监控模式，默认是false。如果设置成true，当应用程序变动时，pm2会自动重载。这里也可以设置你要监控的文件。 max_memory_restart：当内存超过设置的数量时自动重启。 如果工程中有比较棘手的内存泄露问题，这个算是一个折中方案。 instances： 启用多少个实例，可用于负载均衡。仅在cluster模式有效，默认为fork； cron_restart crontab时间格式，定时重启应用，目前只支持cluster模式； 运行实例：已上面的test.json为例 pm2 start ecosystem.config.js ~、环境切换 在实际项目开发中，我们的应用经常需要在多个环境下部署，比如开发环境、测试环境、生产环境等。在不同环境下，有时候配置项会有差异，比如链接的数据库地址不同等。 对于这种场景，pm2也是可以很好支持的。首先通过在配置文件中通过env_xx来声明不同环境的配置，然后在启动应用时，通过–env参数指定运行的环境。 首先，在配置文件中，通过env选项声明多个环境配置。简单说明下： env为默认的环境配置（生产环境），env_dev、env_test则分别是开发、测试环境。可以看到，不同环境下的NODE_ENV、REMOTE_ADDR字段的值是不同的。 在应用中，可以通过process.env.REMOTE_ADDR等来读取配置中生命的变量。 例如： &quot;env&quot;: { &quot;NODE_ENV&quot;: &quot;production&quot;,&quot;REMOTE_ADDR&quot;: &quot;http://www.example.com/&quot;} &quot;env_dev&quot;: { &quot;NODE_ENV&quot;: &quot;development&quot;, &quot;REMOTE_ADDR&quot;: &quot;http://wdev.example.com/&quot;} ​&quot;env_test&quot;: { &quot;NODE_ENV&quot;: &quot;test&quot;, &quot;REMOTE_ADDR&quot;: &quot;http://wtest.example.com/&quot;} 启动指明环境：假设通过下面启动脚本（开发环境），那么，此时process.env.REMOTE_ADDR的值就是相应的链接地址 pm2 start app.js --env dev ~、负载均衡 命令如下，表示开启三个进程。如果-i 0，则会根据机器当前核数自动开启尽可能多的进程。 m2 start app.js -i 3 # 开启三个进程 ​pm2 start app.js -i max # 根据机器CPU核数，开启对应数目的进程 日志查看 除了可以打开日志文件查看日志外，还可以通过pm2 logs来查看实时日志。这点对于线上问题排查非常重要。 比如某个node服务突然异常重启了，那么可以通过pm2提供的日志工具来查看实时日志，看是不是脚本出错之类导致的异常重启。 pm2 logs ~、开机自动启动 可以通过pm2 startup来实现开机自启动。大致流程如下： 通过pm2 save保存当前进程状态。 通过pm2 startup [platform]生成开机自启动的命令。（记得查看控制台输出） 将步骤2生成的命令，粘贴到控制台进行，搞定。 自动重启应用 fork不支持定时重启，cluster支持定时重启。定时重启也就是配置中的cron_restart配置项。 ~、监控(monitor) 运行如下命令，查看当前通过pm2运行的进程的状态。 pm2 monit 内存使用超过上限自动重启 如果想要你的应用，在超过使用内存上限后自动重启，那么可以加上–max-memory-restart参数。（有对应的配置项） pm2 start big-array.js –max-memory-restart 20M 如果你不仅仅想监控被pm2管理的进程，还需要监控进程所运行的机器的信息，你可以使用下面这个API。 pm2 web pm2会启动一个叫做pm2-http-interface的进程提供web服务。你打开浏览器输入 http：//127.0.0.1:9615，是不是被看到的结果惊艳到了。 ~、稳定运行建议 PM2是一款非常优秀的Node进程管理工具，它有着丰富的特性：能够充分利用多核CPU且能够负载均衡、能够帮助应用在崩溃后、指定时间(cluster model)和超出最大内存限制等情况下实现自动重启。 个人几点看法保证常驻应用进程稳定运行： 定时重启，应用进程运行时间久了或许总会产生一些意料之外的问题，定时可以规避一些不可测的情况； 最大内存限制，根据观察设定合理内存限制，保证应用异常运行； 合理min_uptime，min_uptime是应用正常启动的最小持续运行时长，超出此时间则被判定为异常启动； 设定异常重启延时restart_delay，对于异常情况导致应用停止，设定异常重启延迟可防止应用在不可测情况下不断重启的导致重启次数过多等问题； 设置异常重启次数，如果应用不断异常重启，并超过一定的限制次数，说明此时的环境长时间处于不可控状态，服务器异常。此时便可停止尝试，发出错误警告通知等。 ","link":"https://lingtin.github.io/post/mzEtFKB0d/"},{"title":"Nuxt+PM2部署，使用ecosystem.config启动与开发经验","content":"😅😅GIT地址; https://gitee.com/lingtin/common_template_admin ecosystem.config module.exports = { &quot;apps&quot;: [{ &quot;name&quot;: &quot;mp&quot;, &quot;script&quot;: &quot;server/index.js&quot;, &quot;log_date_format&quot;: &quot;YYYY-MM-DD HH:mm:ss&quot;, &quot;error_file&quot;: &quot;log/node-app/node-app.error.log&quot;, &quot;out_file&quot;: &quot;log/node-app.out.log&quot;, &quot;instances&quot;: 3, &quot;min_uptime&quot;: &quot;1000s&quot;, &quot;max_restarts&quot;: 30, &quot;max_memory_restart&quot;: &quot;1G&quot;, &quot;merge_logs&quot;: false, &quot;exec_mode&quot;: &quot;cluster_mode&quot;, &quot;autorestart&quot;: true, &quot;vizion&quot;: false, &quot;exec_interpreter&quot;: &quot;node&quot;, &quot;env&quot;: { &quot;NODE_ENV&quot;: &quot;production&quot; // 环境变量，object类型，如{&quot;NODE_ENV&quot;:&quot;production&quot;, &quot;ID&quot;: &quot;42&quot;}； }, &quot;env_production&quot;: { &quot;NODE_ENV&quot;: &quot;production&quot;, } }] } nuxt.config const PUR = process.env.npm_package_config_nuxt_base_url; const base_url = process.env.NODE_ENV != 'development' ? PUR : 'http://192.168.0.125:8074/' console.log('base_url:' + base_url) const proxy_url = process.env.NODE_ENV != 'development' ? base_url : &quot;/api&quot;; const webmp = process.env.npm_package_config_nuxt_webmp; console.log('spa:' + process.env.NODE_MODE) console.log('NODE_ENV:' + process.env.NODE_ENV) module.exports = { mode: process.env.NODE_MODE ? 'spa' : '', /* ** Headers of the page */ head: { title: &quot;&quot;, meta: [{ charset: 'utf-8' }, { name: 'viewport', content: 'width=device-width, initial-scale=1' }, { hid: 'description', name: 'description', content: &quot;&quot; } ], link: [{ rel: 'icon', type: 'image/x-icon', href: '/favicon.ico' }] }, /* ** Customize the progress-bar color */ loading: { color: '#3399ff' }, pageTransition: &quot;bounce&quot;, /* ** Global CSS */ css: [ 'iview/dist/styles/iview.css', '@/static/styles/comm.css' ], /* ** Plugins to load before mounting the App */ plugins: [ '@/plugins/iview', '@/plugins/defa', '@/plugins/storage', '@/plugins/axios', '@/plugins/apis/user', '@/plugins/apis/sys', { src: '@/plugins/validate', mode: 'client' }, { src: '@/plugins/auth', mode: 'client' } ], /* ** Nuxt.js modules */ env: { baseUrl: base_url }, modules: [ // Doc: https://axios.nuxtjs.org/usage '@nuxtjs/axios', '@nuxtjs/moment' ], moment: { locales: ['es-us'] }, /* ** Axios module configuration */ axios: { proxy: true, // Can be also an object with default options baseURL: proxy_url, browserBaseURL: proxy_url, }, proxy: { '/api/': { target: base_url, pathRewrite: { '^/api': '' } }, '/public': { target: base_url, pathRewrite: { '^/public': '/public/' } } }, router: { // 在每页渲染前运行 middleware/user-agent.js 中间件的逻辑 middleware: ['user-agent', 'auth'], // 所有页面渲染后滚动至顶部 scrollBehavior: function(to, from, savedPosition) { return { // x: 0, y: 0 } }, // 扩展自定义路由 extendRoutes(routes, resolve) { routes.push({ name: '404', path: '*', component: resolve(__dirname, 'pages/Error/404.vue') }) }, base: process.env.NODE_MODE ? `/${webmp}/` : '' }, /* ** Build configuration */ build: { /* ** You can extend webpack config here */ extend(config, ctx) {}, terser: { sourceMap: false, } }, buildDir: 'nuxt-dist', generate: { dir: webmp }, } ","link":"https://lingtin.github.io/post/Mwak-ivNk/"},{"title":"pm2设置开机自动启动服务","content":"自动启动的目的是保存您的进程列表，并在计算机重启甚至出现意外时将其恢复。 每个操作系统都有一个特定的工具来处理启动挂钩：pm2提供了一种简单的方法来生成和配置它们。 设置pm2 根据服务器开关机 自启动 **只需要几个命令 ** ~、 启动进程 sudo pm2 start app ~、 保存当前进程列表 一旦启动了要管理的所有应用程序，就可以通过输入以下命令将该列表保存在预期的/意外的服务器重新启动之中： $ sudo pm2 save 它会将具有相应环境的进程列表保存到转储文件中$PM2_HOME/.pm2/dump.pm2 ~、 检测计算机上可用的init系统并生成配置 把现有已启动服务加到systemd中 $ sudo pm2 startup $ sudo su -c &quot;env PATH=$PATH:/home/unitech/.nvm/versions/node/v4.3/bin pm2 startup 使用NVM时，此pm2路径会在更新Node.js时改变。 每次更新后您都需要运行startup命令。 ~、 重启服务器，发现之前的服务都已经启动 $ sudo reboot ~、 删除自动启动服务 $ sudo pm2 unstartup systemd // 如果不生效： 检查是否是以sudo执行，或者是用su用户操作 pm2 save 之后的文件是否有内容 ~、应用依赖的其它进程是否应启动完成，例如在执行 $ pm2 unstartup systemd 即使已经pm2 delete app，重启后依然会启动服务。 ~、 更新启动脚本 要更新启动脚本（例如，您通过NVM更改了Node.js版本），请运行以下命令： $ pm2 unstartup $ pm2 startup ","link":"https://lingtin.github.io/post/sd8U-nLsh/"},{"title":"使用 pm2-web 监控 pm2 服务运行状态","content":"pm2-web 是一款 pm2 服务状态监控程序，基于 web 。 ~ 安装 $ npm install -g pm2-web ~ 运行(默认是在8080端口) $ pm2-web ~ 配置 pm2-web 将会加载默认的配置文件（如果存在） pm2-web will load one of the following files if they exist (in order of preference) A file specified by the --config /path/to/config.json argument From the current users' home directory: ~/.config/pm2-web/config.json A global configuration file: /etc/pm2-web/config.json ~ 自定义配置文件 通过 --config yourFile 指定加载的配置文件 新建 pm2-web-config.json 文件: { &quot;www&quot;: { &quot;host&quot;: &quot;localhost&quot;, &quot;address&quot;: &quot;0.0.0.0&quot;, &quot;port&quot;: 10016 } } ~ 运行 pm2-web: $pm2-web --config pm2-web-config.json 访问 localhost:10016 可以在 web 界面查看 pm2 服务运行状态，点击按钮进行 stop restart reload 等操作。 可以查看各个服务的内存、CPU使用情况，日志等。 ","link":"https://lingtin.github.io/post/kOpXwFi33/"},{"title":"Linux查看端口占用进程，根据PID kill掉相关进程","content":"本文介绍Linux常规操作：查看端口占用进程，根据PID kill掉相关进程。另外补充：根据程序名查看进程PID。 首先，两条命令，lsof命令和netstat命令。 方式一：lsof命令 1、查看占用端口进程的PID： lsof -i:{端口号} 2、根据PID kill掉相关进程： kill -9 {PID} 方式二：netstat命令 1、查看占用端口进程的PID： netstat -tunlp|grep {port} 2、kill方法如上。 kill -9 {PID} 补充：根据程序名查看对应的PID 1、用ps命令（zb专用）： ps -ef | grep {programName} kill -9 {PID} 2、用pgrep命令： pgrep命令的p表明了这个命令是专门用于进程查询的grep。 pgrep {programName} kill -9 {PID} 隔很长时间不用，就忘了，故记下！ 原文：https://blog.csdn.net/whdxjbw/article/details/80681191 ","link":"https://lingtin.github.io/post/O4ELn5ZNI/"},{"title":"CSS中如何让文字显示方式从右边开始","content":"文字右对齐。向左排表。超过容器时省略 在这种情况下，就有一个非常陌生的属性派上了用场。就是 ： direction: rtl 这个属性规定文本的方向 / 书写方向是从右到左的。 a { display:inline-block; width:100%; white-space:nowrap; text-overflow:ellipsis; -o-text-overflow:ellipsis; overflow: hidden; direction: rtl; } 然后我们再加上超过容器省略文字： a { display:inline-block; width:100%; white-space:nowrap; text-overflow:ellipsis; -o-text-overflow:ellipsis; overflow: hidden; -webkit-line-clamp: 1; //在第几行后开始省略 direction: rtl; } 最终效果便如下图所示。 文章来源：http://wsovo.lofter.com/post/27f1a4_8b601df ","link":"https://lingtin.github.io/post/gxWG-0DqO/"},{"title":"VsCode中安装GO Tools和GoLint失败的问题","content":"在安装go插件时，会自动更新很多依赖库文件，都是从Github更新下来，但是因为Github的文件中，多有应用go官网中的文件，导致，因为网络缘故，不能直接下载，导致安装失败 Installing github.com/nsf/gocode SUCCEEDED Installing github.com/uudashr/gopkgs/cmd/gopkgs SUCCEEDED Installing github.com/ramya-rao-a/go-outline FAILED Installing github.com/acroca/go-symbols FAILED Installing golang.org/x/tools/cmd/guru FAILED Installing golang.org/x/tools/cmd/gorename FAILED Installing github.com/fatih/gomodifytags SUCCEEDED Installing github.com/haya14busa/goplay/cmd/goplay SUCCEEDED Installing github.com/josharian/impl FAILED Installing github.com/rogpeppe/godef SUCCEEDED Installing sourcegraph.com/sqs/goreturns FAILED Installing github.com/golang/lint/golint FAILED Installing github.com/cweill/gotests/... FAILED Installing github.com/derekparker/delve/cmd/dlv SUCCEEDED 8 tools failed to install. 这些失败的库，不是没有下载下来，而是以来的文件在go官网上，导致失败。以下为解决办法， 1、在%GOPATH%\\src\\ 目录下，建立golang.org 文件夹，并再新建x文件夹。 目录为 &quot;%GOPATH\\src\\golang.org\\x&quot; 2、完成目录切换后，开始下载插件包： git clone https://github.com/golang/tools.git tools 3、执行完以后，会多一个tools文件夹。 4、打开vsCode终端，切换到 终端，进入“%GOPATH”目录,执行 go install github.com/ramya-rao-a/go-outline go install github.com/acroca/go-symbols go install golang.org/x/tools/cmd/guru go install golang.org/x/tools/cmd/gorename go install github.com/josharian/impl go install github.com/rogpeppe/godef go install github.com/sqs/goreturns go install github.com/golang/lint/golint go install github.com/cweill/gotests/gotests go install github.com/ramya-rao-a/go-outline go install github.com/acroca/go-symbols go install golang.org/x/tools/cmd/guru go install golang.org/x/tools/cmd/gorename go install github.com/josharian/impl go install github.com/rogpeppe/godef go install github.com/sqs/goreturns go install github.com/golang/lint/golint go install github.com/cweill/gotests/gotests 按此方法，可以安装成功。 后面 golint安装方式 百度很多方法 = = 在cmd中切换到“GOPATH”目录，执行 git clone https://github.com/golang/lint.git 将glint也下载到本地 目录到%GOPATH%\\src\\golang.org\\x 执行： go install golang.org\\x\\lint\\golint 安装完成 参考博文： http://www.pythonsite.com/?p=429 http://blog.csdn.net/langzi7758521/article/details/51313521 ","link":"https://lingtin.github.io/post/dw-XVIReD/"},{"title":"在Visual Studio Code中配置GO开发环境","content":"在Visual Studio Code中配置GO开发环境 一、GO语言安装 详情查看：GO语言下载、安装、https://golang.org/dl/ 二、GoLang插件介绍 对于Visual Studio Code开发工具，有一款优秀的GoLang插件，它的主页为： https://github.com/microsoft/vscode-go 这款插件的特性包括： Colorization 代码着彩色 Completion Lists 代码自动完成（使用gocode） Snippets 代码片段 Quick Info 快速提示信息（使用godef） Goto Definition 跳转到定义（使用godef） Find References 搜索参考引用（使用go-find-references） File outline 文件大纲（使用go-outline） Workspace symbol search 工作区符号搜索（使用 go-symbols） Rename 重命名（使用gorename） Build-on-save 保存构建（使用go build和go test） Format 代码格式化（使用goreturns或goimports或gofmt） Add Imports 添加引用（使用 gopkgs） Debugging 调试代码（使用delve） 三、插件安装 进入Visual Studio Code，使用扩展窗口。 在插件列表中，选择 Go，进行安装，安装之后，系统会提示重启Visual Studio Code。 四、设置环境变量GOPATH 在Windows系统中设置GOPATH环境变量，我的值为D:\\GoWorks 缺少GOPATH环境变量通常会报“$GOPATH not set.”这样的错误。 五、安装Git Windows安装Git的过程省略；安装之后git\\bin配置到PATH环境变量中。 六、执行命令 详情请查看官方网站：https://marketplace.visualstudio.com/items?itemName=lukehoban.Go 安装gocode 打开命令提示符（以管理员身份打开），输入： go get -u -v github.com/nsf/gocode 开始下载： 下载完毕： 下载完成，查看D:\\GoWorks目录，多了一个src\\github.com\\nsf\\gocode路径，如下图： 通过命令行安装以下8个工具。 go get -u -v github.com/nsf/gocode go get -u -v github.com/rogpeppe/godef go get -u -v github.com/golang/lint/golint go get -u -v github.com/lukehoban/go-find-references go get -u -v github.com/lukehoban/go-outline go get -u -v sourcegraph.com/sqs/goreturns go get -u -v golang.org/x/tools/cmd/gorename go get -u -v github.com/tpng/gopkgs go get -u -v github.com/newhook/go-symbols 七 、使用 Hello word 1）File-&gt; Open Folder，现在工作目录： 2）新建go文件 看看，智能提示出来了。 安装方法来源于：https://www.cnblogs.com/zsy/p/5223957.html 详情请查看！ ","link":"https://lingtin.github.io/post/QdBALYczQ/"},{"title":"ES9、ES10特性（速读）","content":"ES9、ES10特性 ES9新特性 异步迭代 ES2018引入异步迭代器（asynchronous iterators），这就像常规迭代器，除了next()方法返回一个Promise。因此await可以和for...of循环一起使用，以串行的方式运行异步操作。 async function process(array) { for await (let i of array) { doSomething(i); } } Promise.finally() 一个Promise调用链要么成功到达最后一个.then()，要么失败触发.catch()。在某些情况下，你想要在无论Promise运行成功还是失败，运行相同的代码，例如清除，删除对话，关闭数据库连接等。 . finally() 允许你指定最终的逻辑： function doSomething() { doSomething1() .then(doSomething2) .then(doSomething3) .catch(err =&gt; { console.log(err); }) .finally(() =&gt; { // finish here! }); } Rest/Spread 属性 Rest参数语法允许我们将一个布丁( 不定)数量的参数表示为一个数组。 restParam(1, 2, 3, 4, 5); function restParam(p1, p2, ...p3) { // p1 = 1 // p2 = 2 // p3 = [3, 4, 5] } 为对象解构提供了和数组一样的Rest参数（）和展开操作符. const myObject = { a: 1, b: 2, c: 3 }; const { a, ...x } = myObject; // a = 1 // x = { b: 2, c: 3 } 正则表达式命名捕获组 ES2018允许命名捕获组使用符号 ? 在打开捕获括号(后立即命名，示例如下： const reDate = /(?&lt;year&gt;[0-9]{4})-(?&lt;month&gt;[0-9]{2})-(?&lt;day&gt;[0-9]{2})/, match = reDate.exec('2018-04-30'), year = match.groups.year, // 2018 month = match.groups.month, // 04 day = match.groups.day; // 30 任何匹配失败的命名组都将返回undefined； 正则表达式反向断言(lookbehind) 先行断言(lookahead)：这意味着匹配会发生，但不会有任何捕获，并且断言没有包含在整个匹配字段中 const reLookahead = /\\D(?=\\d+)/, match = reLookahead.exec('$123.89'); console.log( match[0] ); // $ 反向断言(lookbehind)：注意尖括号 const reLookbehind = /(?&lt;=\\D)\\d+/, match = reLookbehind.exec('$123.89'); console.log( match[0] ); // 123.89 以上是 肯定反向断言，非数字\\D必须存在。同样的，还存在 否定反向断言，表示一个值必须不存在，例如：注意感叹号 const reLookbehindNeg = /(?&lt;!\\D)\\d+/, match = reLookbehind.exec('$123.89'); console.log( match[0] ); // null ES10新特性 新的基本数据类型 BigInt 其中数据类型:String、Number、Boolean、Null、Undefined、Symbol、BigInt 将导入分配给变量 element.addEventListener('click', async() =&gt; { const module = await import(`./api-scripts/button-click.js`); module.clickEvent(); }) Array.flat() 扁平化多维数组 let multi = [1,2,3,[4,5,6,[7,8,9,[10,11,12]]]]; multi.flat(); // [1,2,3,4,5,6,Array(4)] multi.flat().flat(); // [1,2,3,4,5,6,7,8,9,Array(3)] multi.flat().flat().flat(); // [1,2,3,4,5,6,7,8,9,10,11,12] multi.flat(Infinity); // [1,2,3,4,5,6,7,8,9,10,11,12] Array.flatMap() let array = [1, 2, 3, 4, 5]; array.flatMap(v =&gt; [v, v * 2]); [1, 2, 2, 4, 3, 6, 4, 8, 5, 10] Object.fromEntries() Object.entries()方法的作用是返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。 而 Object.fromEntries() 则是 Object.entries() 的反转。 通过 Object.fromEntries， 可以将 Map 转化为 Object: const map1 = new Map([['foo','bar'],['baz',42]]) const obj122 = Object.fromEntries(map1) obj1 //{foo: &quot;bar&quot;, x: 41} 通过 Object.fromEntries， 可以将 Array 转化为 Object: var obj32 = Object.fromEntries(arr1) var obj32 = Object.fromEntries(arr21) obj32 //{0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;} String.trimStart() 与 String.trimEnd() let greeting = &quot; Space around &quot;; greeting.trimEnd(); // &quot; Space around&quot;; greeting.trimStart(); // &quot;Space around &quot;; Function.prototype.toString()现在返回精确字符，包括空格和注释 头部和尾部的注释不显示 修改 catch 绑定 之前是try {}catch(e){} 现在是try {}catch{} ","link":"https://lingtin.github.io/post/T4tGUJp80/"},{"title":"Push.js-桌面通知库","content":"Push.js是一个可以快速运行和接收的桌面通知库，它可以应用在网页消息推送方面，而且简单易用。 演示地址 github地址 安装 我们可以使用npm快速安装。 npm install push.js --save 使用 运行push接收通知非常简单，以下代码就可以创建一个新的通知： Push.create('Hello World!'); 我们还可以传入参数对象，定制通知效果， Push.create(&quot;Hello world!&quot;, { body: &quot;Welcome to Helloweba.net&quot;, icon: '/icon.png', timeout: 4000, onClick: function () { window.focus(); this.close(); } }); 我们也可以使用Push.close()方法来手动关闭通知界面。 Push.create('Hello World!', { tag: 'foo' }); // Somewhere later in your code... Push.close('foo'); 选项和配置 以下是常用的选项配置： body：通知的主体内容。 data：数据传递给ServiceWorker通知。 requireInteraction：如果设置成true的话，通知不会自动关闭，除非人工手动点击关闭。 icon：可以设置通知界面上大小为16x16或32x32像素的小图标。 link：当用户点击移动设备上的通知时，则会导航到对应的页面上。 tag：标记通知，后面关闭通知可以通过该标记来识别是要关闭哪条通知。 timeout：通知自动关闭的时间，毫秒。 onClick()：回调，当点击通知界面的时候触发。 onClose()：回调，当要关闭通知的时候触发。 onError()：回调，当通知抛出错误的时候触发。 onShow()：回调，当显示通知的时候触发。 Push.js还提供了一个.config()方法用于全局配置。 Push.config({ serviceWorker: './customServiceWorker.js', // Sets a custom service worker script fallback: function(payload) { // Code that executes on browsers with no notification support // &quot;payload&quot; is an object containing the // title, body, tag, and icon of the notification } }); 权限 基于浏览器的通知需要浏览器授予权限，当前浏览器会弹出询问窗口，当你通过允许后，才会正式调用通知库。 ","link":"https://lingtin.github.io/post/YSeQh9MIn/"},{"title":"CSS3 loading三圆点加载动画","content":"three-dots.css是一款CSS3 loading三圆点加载动画特效库。集成了14种三圆点loading动画特效，以及三种增强动画效果。 演示地址 github地址 安装 可以通过npm来安装three-dots.css。 npm install three-dots --save 使用方法 在页面中引入three-dots.css。 &lt;link href=&quot;css/three-dots.css&quot; rel=&quot;stylesheet&quot;&gt; HTML结构 然后在你需要添加Loading效果的容器上添加相应的class类即可。 &lt;div class=&quot;dot-elastic&quot;&gt;&lt;/div&gt; &lt;div class=&quot;dot-pulse&quot;&gt;&lt;/div&gt; &lt;div class=&quot;dot-flashing&quot;&gt;&lt;/div&gt; &lt;div class=&quot;dot-collision&quot;&gt;&lt;/div&gt; &lt;div class=&quot;dot-revolution&quot;&gt;&lt;/div&gt; &lt;div class=&quot;dot-translation&quot;&gt;&lt;/div&gt; &lt;div class=&quot;dot-typing&quot;&gt;&lt;/div&gt; &lt;div class=&quot;dot-windmill&quot;&gt;&lt;/div&gt; &lt;div class=&quot;dot-bricks&quot;&gt;&lt;/div&gt; &lt;div class=&quot;dot-floating&quot;&gt;&lt;/div&gt; 可用的class类有： dot-elastic dot-pulse dot-flashing dot-collision dot-revolution dot-carousel dot-typing dot-windmill dot-bricks dot-floating dot-fire dot-spin dot-falling dot-stretching ","link":"https://lingtin.github.io/post/iLEYbNwwv/"},{"title":"表单上传控件Files筛选指定格式的文件：accept属性过滤文件","content":"⚽️🏀表单上传控件Files筛选指定格式 （IE9及以下不支持下面这些功能，其它浏览器最新版本均已支持。） 1、允许上传文件数量 允许选择多个文件： &lt;input type=&quot;file&quot; multiple&gt; 只允许上传一个文件： &lt;input type=&quot;file&quot; single&gt; 2、上传指定的文件格式 &lt;input type=&quot;file&quot; accept=&quot;image/gif,image/png&quot; /&gt; 这里的上传格式仅指打开上传弹窗选择文件时默认的文件格式，可手动修改成其它文件格式。 如果不限制上传图片的格式可写成：accept=&quot;image/*&quot; 其它格式参考如下： *.3gpp audio/3gpp, video/3gpp 3GPP Audio/Video *.ac3 audio/ac3 AC3 Audio *.asf allpication/vnd.ms-asf Advanced Streaming Format *.au audio/basic AU Audio *.css text/css Cascading Style Sheets *.csv text/csv Comma Separated Values *.doc application/msword MS Word Document *.dot application/msword MS Word Template *.dtd application/xml-dtd Document Type Definition *.dwg image/vnd.dwg AutoCAD Drawing Database *.dxf image/vnd.dxf AutoCAD Drawing Interchange Format *.gif image/gif Graphic Interchange Format *.htm text/html HyperText Markup Language *.html text/html HyperText Markup Language *.jp2 image/jp2 JPEG-2000 *.jpe image/jpeg JPEG *.jpeg image/jpeg JPEG *.jpg image/jpeg JPEG *.js text/javascript, application/javascript JavaScript *.json application/json JavaScript Object Notation *.mp2 audio/mpeg, video/mpeg MPEG Audio/Video Stream, Layer II *.mp3 audio/mpeg MPEG Audio Stream, Layer III *.mp4 audio/mp4, video/mp4 MPEG-4 Audio/Video *.mpeg video/mpeg MPEG Video Stream, Layer II *.mpg video/mpeg MPEG Video Stream, Layer II *.mpp application/vnd.ms-project MS Project Project *.ogg application/ogg, audio/ogg Ogg Vorbis *.pdf application/pdf Portable Document Format *.png image/png Portable Network Graphics *.pot application/vnd.ms-powerpoint MS PowerPoint Template *.pps application/vnd.ms-powerpoint MS PowerPoint Slideshow *.ppt application/vnd.ms-powerpoint MS PowerPoint Presentation *.rtf application/rtf, text/rtf Rich Text Format *.svf image/vnd.svf Simple Vector Format *.tif image/tiff Tagged Image Format File *.tiff image/tiff Tagged Image Format File *.txt text/plain Plain Text *.wdb application/vnd.ms-works MS Works Database *.wps application/vnd.ms-works Works Text Document *.xhtml application/xhtml+xml Extensible HyperText Markup Language *.xlc application/vnd.ms-excel MS Excel Chart *.xlm application/vnd.ms-excel MS Excel Macro *.xls application/vnd.ms-excel MS Excel Spreadsheet *.xlt application/vnd.ms-excel MS Excel Template *.xlw application/vnd.ms-excel MS Excel Workspace *.xml text/xml, application/xml Extensible Markup Language *.zip aplication/zip Compressed Archive 示例 &lt;p&gt;显示 .xls, .xlsx, .csv 文件...&lt;/p&gt; &lt;input type=&quot;file&quot; accept=&quot;.csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel&quot; ID=&quot;fileSelect&quot; runat=&quot;server&quot; /&gt; &lt;p&gt;只显示 Excel (.xlsx) 文件...&lt;/p&gt; &lt;input type=&quot;file&quot; accept=&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot; ID=&quot;fileSelect&quot; runat=&quot;server&quot; /&gt; &lt;p&gt;只显示 Excel (.xls) 文件...&lt;/p&gt; &lt;input type=&quot;file&quot; accept=&quot;application/vnd.ms-excel&quot; ID=&quot;fileSelect&quot; runat=&quot;server&quot; /&gt; &lt;p&gt;只显示图片.&lt;/p&gt; &lt;input type=&quot;file&quot; accept=&quot;image/*&quot; ID=&quot;fileSelect&quot; runat=&quot;server&quot; /&gt; &lt;p&gt;只显示文本文件...&lt;/p&gt; &lt;input type=&quot;file&quot; accept=&quot;text/plain&quot; ID=&quot;fileSelect&quot; runat=&quot;server&quot; /&gt; &lt;p&gt;只显示html文件.&lt;/p&gt; &lt;input type=&quot;file&quot; accept=&quot;text/html&quot; ID=&quot;fileSelect&quot; runat=&quot;server&quot; /&gt; &lt;p&gt;只显示 video 文件..&lt;/p&gt; &lt;input type=&quot;file&quot; accept=&quot;video/*&quot; ID=&quot;fileSelect&quot; runat=&quot;server&quot; /&gt; &lt;p&gt;只显示 audio 文件...&lt;/p&gt; &lt;input type=&quot;file&quot; accept=&quot;audio/*&quot; ID=&quot;fileSelect&quot; runat=&quot;server&quot; /&gt; &lt;p&gt;只显示 .WAV 文件...&lt;/p&gt; &lt;input type=&quot;file&quot; accept=&quot;.wav&quot; ID=&quot;fileSelect&quot; runat=&quot;server&quot; /&gt; &lt;p&gt;只显示 .PDF 文件...&lt;/p&gt; &lt;input type=&quot;file&quot; accept=&quot;.pdf&quot; ID=&quot;fileSelect&quot; runat=&quot;server&quot; /&gt; ","link":"https://lingtin.github.io/post/e_nXbAwWE/"},{"title":"使用NCU更新模块同步package.js","content":"模块检查更新,使用NCU更新模块同步package.js 在用vue-cli生成工程后，一段时间很多模块都有更新，如何把工程中的模块都更新到最新的呢。 首先我们先通过命令查看下需要更新的版本： npm outdated npm outdated 会列出所有可更新的 node_modules，如下： Package Current Wanted Latest Location autoprefixer 6.7.2 6.7.2 7.1.2 vue-test babel-core 6.22.1 6.22.1 6.25.0 vue-test babel-eslint 7.1.1 7.1.1 7.2.3 vue-test babel-loader 6.2.10 6.2.10 7.1.1 vue-test babel-plugin-transform-runtime 6.22.0 6.22.0 6.23.0 vue-test babel-preset-env 1.3.2 1.3.2 1.6.0 vue-test babel-preset-stage-2 6.22.0 6.22.0 6.24.1 vue-test babel-register 6.22.0 6.22.0 6.24.1 vue-test chalk 1.1.3 1.1.3 2.0.1 vue-test css-loader 0.28.0 0.28.0 0.28.4 vue-test element-ui 1.3.7 1.3.7 1.4.1 vue-test 比如我的element-ui模块，当前是版本是1.3.7，而最新的版本，是1.4.1。 但是执行 npm update 更新命令，只能按照package.js中标注的版本号，进行更新，所以每次都要改下package.js中的版本号为最新才能够更新，太麻烦，没什么用处。那还有没有更好的办法呢，当然有，就是高效升级插件npm-check-updates 安装方法 npm install -g npm-check-updates 查看最新的版本 ncu -v 下一个是指令缩写，更方便，执行后，会列出所有要更新的组件： E:\\Vue\\vueAdmin-template-master&gt;ncu Using E:\\Vue\\vueAdmin-template-master\\package.json [..................] \\ : element-ui 1.3.7 → 1.4.1 normalize.css 3.0.2 → 7.0.0 vue 2.3.3 → 2.4.2 vue-router 2.5.3 → 2.7.0 autoprefixer 6.7.2 → 7.1.2 babel-core 6.22.1 → 6.25.0 babel-eslint 7.1.1 → 7.2.3 babel-loader 6.2.10 → 7.1.1 升级 这说明有些包需要升级 这时候我们使用 ncu -a 就可以全部升级了。 当然，如果所有包都是最新版本，执行ncu后会提示： All dependencies match the latest package versions 😃 ","link":"https://lingtin.github.io/post/yWeZyt6_w/"},{"title":"Nodejs+Egg微信/app/小程序支付","content":"微信支付 app/小程序支付 企业付款到零钱文档；https://pay.weixin.qq.com/wiki/doc/api/tools/mch_pay.php?chapter=14_2 1、微信支付，先看流程图 https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=8_3 先看流程图，看懂，再看微信支付api 2、调用统一下单接口 Controller import {Controller} from 'egg'; export default class Wx extends Controller{ public async wxpay(){ const ctx = this.ctx; const result = await ctx.service.weixin.payunifiedorder(); ctx.body = result; } /* 微信回调 */ public async wxNotify(){ const ctx = this.ctx; const result = await ctx.service.weixin.wxNotify(ctx.params); ctx.body = result } } Service import { Service } from 'egg'; import * as xmlbuilder from 'xmlbuilder'; import * as uuidv5 from 'uuid/v5'; import * as qs from 'qs'; import * as md5 from 'md5'; const appid:string=&quot;appid&quot;; const secret:string=&quot;secret&quot; export default class Weixin extends Service{ /* 获取微信openid */ public async getUserOpenid({code}):Promise&lt;object&gt;{ const ctx = this.ctx; const result = await ctx.curl(`https://api.weixin.qq.com/sns/jscode2session?appid=${appid}&amp;secret=${secret}=&amp;js_code=${code}&amp;grant_type=authorization_code`,{ method:&quot;GET&quot; }); return result.data; } /* 获取微信access_token */ public async getAccess_token():Promise&lt;object&gt;{ const ctx = this.ctx; const result = await ctx.curl(`https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=${appid}&amp;secret=${secret}`,{ method:&quot;GET&quot; }); return result.data; } /* 统一下单 */ public async payunifiedorder():Promise&lt;object&gt;{ const ctx = this.ctx; let uuid = uuidv5(&quot;&quot;,uuidv5.DNS).replace(/-/g, '').toUpperCase() console.log(ctx.ip.replace(/::ffff:/g, '')) let order:any={ appid, body:&quot;腾讯充值中心-QQ会员充值&quot;, nonce_str:uuid, notify_url:&quot;http://x5z5g2.natappfree.cc/getpay&quot;, out_trade_no:uuid, spbill_create_ip:&quot;123.12.12.123&quot;, total_fee:1, trade_type:&quot;APP&quot;, } const objStr = qs.stringify(order) const preSign = objStr + '&amp;key=192006250b4c09247ec02edce69f6a2d' order.sign = md5(preSign).toUpperCase(); let xml = xmlbuilder.create(order).end({ pretty: true}); const result:any = await ctx.curl(`https://api.mch.weixin.qq.com/pay/unifiedorder`,{ method:'POST', data:xml }); console.log(result.data) //二次签名，返回给app即可，由app端进行微信支付吊起 const paysign2:any = { appid: result.data.appid[0], noncestr: result.data.nonce_str[0], package: 'Sign=WXPay', partnerid: result.data.mch_id[0], prepayid: result.data.prepay_id[0], timestamp:Number(Date.now() / 1000) //注意：时间必需为秒 }; const payPrestr = qs.stringify(paysign2) + 'key=微信商户平台的key' //不知道的话，可以问老板 paysign2.sign = md5(payPrestr).toUpperCase() return paysign2; } // 微信回调 public async wxNotify(params){ const ctx = this.ctx; // 接受微信参数 var payQuery:any = { appid: params.appid[0], mch_id: params.mch_id[0], nonce_str: params.nonce_str[0], out_trade_no: params.out_trade_no[0], transaction_id: params.transaction_id[0] } let payQueryString = qs.stringify(payQuery) + 'key=微信商户平台的key' payQuery.sign = md5(payQueryString).toUpperCase() let payQueryxml = xmlbuilder.create(payQuery).end({ pretty: true}); //查询订单是否支付成功 const result:any = await ctx.curl(`https://api.mch.weixin.qq.com/pay/orderquery`,{ method:'POST', data:payQueryxml }); if (result.data.xml.return_code[0] &amp;&amp; result.xml.return_code[0] == 'SUCCESS' &amp;&amp; result.xml.trade_state[0] == 'SUCCESS' ) { //告诉微信，你收到支付结果通知了 let res = { return_code:&quot;&lt;![CDATA[SUCCESS]]&gt;&quot;, return_msg:&quot;&lt;![CDATA[OK]]&gt;&quot; } let resxml = xmlbuilder.create(res).end({ pretty: true}); return resxml; } } } ","link":"https://lingtin.github.io/post/kx0wh7zZA/"},{"title":"H5 双端库集合（二）","content":"👍👍 vue库集合 👍👍 库集合 Mand Mobile Mand Mobile是面向金融场景设计的移动端组件库，基于Vue.js实现。目前已实际应用于滴滴四大金融业务板块的10余款产品中。 提供按需加载能力，使用灵活，避免引入无用代码，导出es，umd两种格式以及px, vh/vw两种样式单位 灵活转换的样式主题 UI样式可配置，拓展灵活，轻松适应不同的设计风格 支持TypeScript 支持服务端渲染 官网链接：didi.github.io/mand-mobile/#/zh-CN/home GitHub：https://github.com/didi/mand-mobile/tree/master cube-ui cube-ui 是基于 Vue.js 实现的精致移动端组件库。 支持按需引入和后编译，轻量灵活；扩展性强，可以方便地基于现有组件实现二次开发。 官网链接：https://didi.github.io/cube-ui/#/zh-CN Vant Vant 轻量、可靠的移动端 Vue 组件库 是有赞移动端组件库 官网链接：https://youzan.github.io/vant/#/zh-CN/intro Vue-ydui Vue-ydui 是 YDUI Touch 的一个Vue2.x实现版本，专为移动端打造，在追求完美视觉体验的同时也保证了其性能高效。 官网链接：http://vue.ydui.org/ mpvue mpvue 是一个使用 Vue.js 开发小程序的前端框架，目前支持 微信小程序、百度智能小程序，头条小程序 和 支付宝小程序。 框架基于 Vue.js，修改了的运行时框架 runtime 和代码编译器 compiler 实现，使其可运行在小程序环境中，从而为小程序开发引入了 Vue.js 开发体验。 官网链接：http://mpvue.com/ AT-UI AT-UI 是一款基于 Vue.js 2.0 的前端 UI 组件库，主要用于快速开发 PC 网站中后台产品 CSS 样式独立，即使使用不同的框架实现，也都能保持统一的 UI 风格（ 详见：AT-UI Style ） 提供友好的 API，可灵活的使用组件。 官网链接： https://at-ui.github.io/at-ui/#/zh Element UI 饿了么 - 基于 Vue 的组件库 官网链接：https://element.eleme.cn/#/zh-CN iView iView 是一套基于 Vue.js 的开源 UI 组件库，主要服务于 PC 界面的中后台产品。 官网链接：https://element.eleme.cn/#/zh-CN HeyUI HeyUI 是一套基于 Vue2.0 的开源 UI 组件库，主要服务于一些中后台产品。 特性 HeyUI提供的是一整套解决方案，所有的组件提供全局的可配置模式。 真正的数据驱动 全局的配置模式 数据字典化 官网链接：https://www.heyui.top/ GitHub：https://github.com/heyui/heyui Ant Design of Vue 基于 Ant Design 设计语言 Ant Design 的 Vue 实现，开发和服务于企业级后台产品。 官网链接：https://vue.ant.design/ Muse-UI Muse UI 是一套 Material Design 风格开源组件库，旨在快速搭建页面。它基于 Vue 2.0 开发，并提供了自定义主题，充分满足可定制化的需求。 官网链接：https://muse-ui.org/#/zh-CN GitHub：https://github.com/museui/muse-ui ","link":"https://lingtin.github.io/post/XhORDmL-X/"},{"title":"ES6、ES7、ES8新特性(速读)","content":"😇😇 ES全称ECMAScript，ECMAScript是ECMA制定的标准化脚本语言。目前JavaScript使用的ECMAScript版本为ECMAScript-262。 ECMAScript 标准建立在一些原有的技术上，最为著名的是 JavaScript (网景) 和 JScript (微软)。它最初由网景的 Brendan Eich 发明，第一次出现是在网景的 Navigator 2.0 浏览器上。Netscape 2.0 以及微软 Internet Explorer 3.0 后序的所有浏览器上都有它的身影。 ECMAScript 2009(ES5) 2009年11月 扩展了Object、Array、Function的功能等 ECMAScript 2015(ES6) 2015年6月 类，模块化，箭头函数，函数参数默认值等 ECMAScript 2016(ES7) 2016年3月 includes，指数操作符 ECMAScript 2017(ES8) 2017年6月 sync/await，Object.values()，Object.entries()，String padding等 了解这些特性，不仅能使我们的编码更加的符合规范，而且能提高我们Coding的效率。 ES6的特性比较多，在 ES5 发布近 6 年（2009-11 至 2015-6）之后才将其标准化。两个发布版本之间时间跨度很大，所以ES6中的特性比较多。 在这里列举几个常用的： 类 模块化 箭头函数 函数参数默认值 模板字符串 解构赋值 延展操作符 对象属性简写 Promise Let与Const 1.类（class） 对熟悉Java，object-c，c#等纯面向对象语言的开发者来说，都会对class有一种特殊的情怀。ES6 引入了class（类），让JavaScript的面向对象编程变得更加简单和易于理解。 class Animal { // 构造函数，实例化的时候将会被调用，如果不指定，那么会有一个不带参数的默认构造函数. constructor(name,color) { this.name = name; this.color = color; } // toString 是原型对象上的属性 toString() { console.log('name:' + this.name + ',color:' + this.color); } } var animal = new Animal('dog','white');//实例化Animal animal.toString(); console.log(animal.hasOwnProperty('name')); //true console.log(animal.hasOwnProperty('toString')); // false console.log(animal.__proto__.hasOwnProperty('toString')); // true class Cat extends Animal { constructor(action) { // 子类必须要在constructor中指定super 函数，否则在新建实例的时候会报错. // 如果没有置顶consructor,默认带super函数的constructor将会被添加、 super('cat','white'); this.action = action; } toString() { console.log(super.toString()); } } var cat = new Cat('catch') cat.toString(); // 实例cat 是 Cat 和 Animal 的实例，和Es5完全一致。 console.log(cat instanceof Cat); // true console.log(cat instanceof Animal); // true 2.模块化(Module) ES5不支持原生的模块化，在ES6中模块作为重要的组成部分被添加进来。模块的功能主要由 export 和 import 组成。每一个模块都有自己单独的作用域，模块之间的相互调用关系是通过 export 来规定模块对外暴露的接口，通过import来引用其它模块提供的接口。同时还为模块创造了命名空间，防止函数的命名冲突。 导出(export) ES6允许在一个模块中使用export来导出多个变量或函数。 导出变量 //test.js export var name = 'Rainbow' 心得：ES6不仅支持变量的导出，也支持常量的导出。 export const sqrt = Math.sqrt;//导出常量 ES6将一个文件视为一个模块，上面的模块通过 export 向外输出了一个变量。一个模块也可以同时往外面输出多个变量。 //test.js var name = 'Rainbow'; var age = '24'; export {name, age}; 复制代码导出函数 // myModule.js export function myModule(someArg) { return someArg; } 导入(import) 定义好模块的输出以后就可以在另外一个模块通过import引用。 import {myModule} from 'myModule';// main.js import {name,age} from 'test';// test.js 心得:一条import 语句可以同时导入默认函数和其它变量。import defaultMethod, { otherMethod } from 'xxx.js'; 3.箭头（Arrow）函数 这是ES6中最令人激动的特性之一。=&gt;不只是关键字function的简写，它还带来了其它好处。箭头函数与包围它的代码共享同一个this,能帮你很好的解决this的指向问题。有经验的JavaScript开发者都熟悉诸如var self = this;或var that = this这种引用外围this的模式。但借助=&gt;，就不需要这种模式了。 箭头函数的结构 箭头函数的箭头=&gt;之前是一个空括号、单个的参数名、或用括号括起的多个参数名，而箭头之后可以是一个表达式（作为函数的返回值），或者是用花括号括起的函数体（需要自行通过return来返回值，否则返回的是undefined）。 // 箭头函数的例子 ()=&gt;1 v=&gt;v+1 (a,b)=&gt;a+b ()=&gt;{ alert(&quot;foo&quot;); } e=&gt;{ if (e == 0){ return 0; } return 1000/e; } 心得：不论是箭头函数还是bind，每次被执行都返回的是一个新的函数引用，因此如果你还需要函数的引用去做一些别的事情（譬如卸载监听器），那么你必须自己保存这个引用。 卸载监听器时的陷阱 错误的做法 class PauseMenu extends React.Component{ componentWillMount(){ AppStateIOS.addEventListener('change', this.onAppPaused.bind(this)); } componentWillUnmount(){ AppStateIOS.removeEventListener('change', this.onAppPaused.bind(this)); } onAppPaused(event){ } } 正确的做法 class PauseMenu extends React.Component{ constructor(props){ super(props); this._onAppPaused = this.onAppPaused.bind(this); } componentWillMount(){ AppStateIOS.addEventListener('change', this._onAppPaused); } componentWillUnmount(){ AppStateIOS.removeEventListener('change', this._onAppPaused); } onAppPaused(event){ } } 除上述的做法外，我们还可以这样做： class PauseMenu extends React.Component{ componentWillMount(){ AppStateIOS.addEventListener('change', this.onAppPaused); } componentWillUnmount(){ AppStateIOS.removeEventListener('change', this.onAppPaused); } onAppPaused = (event) =&gt; { //把函数直接作为一个arrow function的属性来定义，初始化的时候就绑定好了this指针 } } 需要注意的是：不论是bind还是箭头函数，每次被执行都返回的是一个新的函数引用，因此如果你还需要函数的引用去做一些别的事情（譬如卸载监听器），那么你必须自己保存这个引用。 4.函数参数默认值 ES6支持在定义函数的时候为其设置默认值： function foo(height = 50, color = 'red') { // ... } 不使用默认值： function foo(height, color) { var height = height || 50; var color = color || 'red'; //... } 这样写一般没问题，但当参数的布尔值为false时，就会有问题了。比如，我们这样调用foo函数： foo(0, &quot;&quot;) 复制代码因为0的布尔值为false，这样height的取值将是50。同理color的取值为‘red’。 所以说，函数参数默认值不仅能是代码变得更加简洁而且能规避一些问题。 5.模板字符串 ES6支持模板字符串，使得字符串的拼接更加的简洁、直观。 不使用模板字符串： var name = 'Your name is ' + first + ' ' + last + '.' 使用模板字符串： var name = `Your name is ${first} ${last}.` 在ES6中通过${}就可以完成字符串的拼接，只需要将变量放在大括号之中。 6.解构赋值 解构赋值语法是JavaScript的一种表达式，可以方便的从数组或者对象中快速提取值赋给定义的变量。 获取数组中的值 从数组中获取值并赋值到变量中，变量的顺序与数组中对象顺序对应。 var foo = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]; var [one, two, three] = foo; console.log(one); // &quot;one&quot; console.log(two); // &quot;two&quot; console.log(three); // &quot;three&quot; //如果你要忽略某些值，你可以按照下面的写法获取你想要的值 var [first, , , last] = foo; console.log(first); // &quot;one&quot; console.log(last); // &quot;four&quot; //你也可以这样写 var a, b; //先声明变量 [a, b] = [1, 2]; console.log(a); // 1 console.log(b); // 2 如果没有从数组中的获取到值，你可以为变量设置一个默认值。 var a, b; [a=5, b=7] = [1]; console.log(a); // 1 console.log(b); // 7 通过解构赋值可以方便的交换两个变量的值。 var a = 1; var b = 3; [a, b] = [b, a]; console.log(a); // 3 console.log(b); // 1 获取对象中的值 const student = { name:'Ming', age:'18', city:'Shanghai' }; const {name,age,city} = student; console.log(name); // &quot;Ming&quot; console.log(age); // &quot;18&quot; console.log(city); // &quot;Shanghai&quot; 7.延展操作符(Spread operator) 延展操作符...可以在函数调用/数组构造时, 将数组表达式或者string在语法层面展开；还可以在构造对象时, 将对象表达式按key-value的方式展开。 语法 函数调用： myFunction(...iterableObj); 数组构造或字符串： [...iterableObj, '4', ...'hello', 6]; 构造对象时,进行克隆或者属性拷贝（ECMAScript 2018规范新增特性）： let objClone = { ...obj }; 应用场景 在函数调用时使用延展操作符 function sum(x, y, z) { return x + y + z; } const numbers = [1, 2, 3]; //不使用延展操作符 console.log(sum.apply(null, numbers)); //使用延展操作符 console.log(sum(...numbers));// 6 构造数组 没有展开语法的时候，只能组合使用 push，splice，concat 等方法，来将已有数组元素变成新数组的一部分。有了展开语法, 构造新数组会变得更简单、更优雅： const stuendts = ['Jine','Tom']; const persons = ['Tony',... stuendts,'Aaron','Anna']; conslog.log(persions)// [&quot;Tony&quot;, &quot;Jine&quot;, &quot;Tom&quot;, &quot;Aaron&quot;, &quot;Anna&quot;] 和参数列表的展开类似, ... 在构造字数组时, 可以在任意位置多次使用。 数组拷贝 var arr = [1, 2, 3]; var arr2 = [...arr]; // 等同于 arr.slice() arr2.push(4); console.log(arr2)//[1, 2, 3, 4] 展开语法和 Object.assign() 行为一致, 执行的都是浅拷贝(只遍历一层)。 连接多个数组 var arr1 = [0, 1, 2]; var arr2 = [3, 4, 5]; var arr3 = [...arr1, ...arr2];// 将 arr2 中所有元素附加到 arr1 后面并返回 //等同于 var arr4 = arr1.concat(arr2); 在ECMAScript 2018中延展操作符增加了对对象的支持 var obj1 = { foo: 'bar', x: 42 }; var obj2 = { foo: 'baz', y: 13 }; var clonedObj = { ...obj1 }; // 克隆后的对象: { foo: &quot;bar&quot;, x: 42 } var mergedObj = { ...obj1, ...obj2 }; // 合并后的对象: { foo: &quot;baz&quot;, x: 42, y: 13 } 在React中的应用 通常我们在封装一个组件时，会对外公开一些 props 用于实现功能。大部分情况下在外部使用都应显示的传递 props 。但是当传递大量的props时，会非常繁琐，这时我们可以使用 ...(延展操作符,用于取出参数对象的所有可遍历属性) 来进行传递。 一般情况下我们应该这样写 &lt;CustomComponent name ='Jine' age ={21} /&gt; 使用 ... ，等同于上面的写法 const params = { name: 'Jine', age: 21 } &lt;CustomComponent {...params} /&gt; 配合解构赋值避免传入一些不需要的参数 var params = { name: '123', title: '456', type: 'aaa' } var { type, ...other } = params; &lt;CustomComponent type='normal' number={2} {...other} /&gt; //等同于 &lt;CustomComponent type='normal' number={2} name='123' title='456' /&gt; 8.对象属性简写 在ES6中允许我们在设置一个对象的属性的时候不指定属性名。 不使用ES6 const name='Ming',age='18',city='Shanghai'; const student = { name:name, age:age, city:city }; console.log(student);//{name: &quot;Ming&quot;, age: &quot;18&quot;, city: &quot;Shanghai&quot;} 对象中必须包含属性和值，显得非常冗余。 使用ES6 const name='Ming',age='18',city='Shanghai'; const student = { name, age, city }; console.log(student);//{name: &quot;Ming&quot;, age: &quot;18&quot;, city: &quot;Shanghai&quot;} 对象中直接写变量，非常简洁。 9.Promise Promise 是异步编程的一种解决方案，比传统的解决方案callback更加的优雅。它最早由社区提出和实现的，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 不使用ES6 嵌套两个setTimeout回调函数： setTimeout(function() { console.log('Hello'); // 1秒后输出&quot;Hello&quot; setTimeout(function() { console.log('Hi'); // 2秒后输出&quot;Hi&quot; }, 1000); }, 1000); 使用ES6 var waitSecond = new Promise(function(resolve, reject) { setTimeout(resolve, 1000); }); waitSecond .then(function() { console.log(&quot;Hello&quot;); // 1秒后输出&quot;Hello&quot; return waitSecond; }) .then(function() { console.log(&quot;Hi&quot;); // 2秒后输出&quot;Hi&quot; }); 上面的的代码使用两个then来进行异步编程串行化，避免了回调地狱： 10.支持let与const 在之前JS是没有块级作用域的，const与let填补了这方便的空白，const与let都是块级作用域。 使用var定义的变量为函数级作用域： { var a = 10; } console.log(a); // 输出10 使用let与const定义的变量为块级作用域： { let a = 10; } console.log(a); //-1 or Error“ReferenceError: a is not defined” ES7的特性 在ES6之后，ES的发布频率更加频繁，基本每年一次，所以自ES6之后，每个新版本的特性的数量就比较少。 includes() 指数操作符 Array.prototype.includes() includes() 函数用来判断一个数组是否包含一个指定的值，如果包含则返回 true，否则返回false。 includes 函数与 indexOf 函数很相似，下面两个表达式是等价的： arr.includes(x) arr.indexOf(x) &gt;= 0 接下来我们来判断数字中是否包含某个元素： 在ES7之前的做法 使用indexOf()验证数组中是否存在某个元素，这时需要根据返回值是否为-1来判断： let arr = ['react', 'angular', 'vue']; if (arr.indexOf('react') !== -1) { console.log('react存在'); } 使用ES7的includes() 使用includes()验证数组中是否存在某个元素，这样更加直观简单： let arr = ['react', 'angular', 'vue']; if (arr.includes('react')) { console.log('react存在'); } 2.指数操作符 在ES7中引入了指数运算符**，**具有与Math.pow(..)等效的计算结果。 不使用指数操作符 使用自定义的递归函数calculateExponent或者Math.pow()进行指数运算： function calculateExponent(base, exponent) { if (exponent === 1) { return base; } else { return base * calculateExponent(base, exponent - 1); } } console.log(calculateExponent(2, 10)); // 输出1024 console.log(Math.pow(2, 10)); // 输出1024 使用指数操作符 使用指数运算符**，就像+、-等操作符一样： console.log(2**10);// 输出1024 复制代码ES8的特性 async/await Object.values() Object.entries() String padding 函数参数列表结尾允许逗号 Object.getOwnPropertyDescriptors() 浏览器兼容性 1.async/await 在ES8中加入了对async/await的支持，也就我们所说的异步函数，这是一个很实用的功能。 async/await将我们从头痛的回调地狱中解脱出来了，使整个代码看起来很简洁。 使用async/await与不使用async/await的差别： login(userName) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('1001'); }, 600); }); } getData(userId) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { if (userId === '1001') { resolve('Success'); } else { reject('Fail'); } }, 600); }); } // 不使用async/await ES7 doLogin(userName) { this.login(userName) .then(this.getData) .then(result =&gt; { console.log(result) }) } // 使用async/await ES8 async doLogin2(userName) { const userId=await this.login(userName); const result=await this.getData(userId); } this.doLogin()// Success this.doLogin2()// Success async/await的几种应用场景 接下来我们来看一下async/await的几种应用场景。 获取异步函数的返回值 异步函数本身会返回一个Promise，所以我们可以通过then来获取异步函数的返回值。 async function charCountAdd(data1, data2) { const d1=await charCount(data1); const d2=await charCount(data2); return d1+d2; } charCountAdd('Hello','Hi').then(console.log);//通过then获取异步函数的返回值。 function charCount(data) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(data.length); }, 1000); }); } async/await在并发场景中的应用 对于上述的例子，我们调用await两次，每次都是等待1秒一共是2秒，效率比较低，而且两次await的调用并没有依赖关系，那能不能让其并发执行呢，答案是可以的，接下来我们通过Promise.all来实现await的并发调用。 async function charCountAdd(data1, data2) { const [d1,d2]=await Promise.all([charCount(data1),charCount(data2)]); return d1+d2; } charCountAdd('Hello','Hi').then(console.log); function charCount(data) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(data.length); }, 1000); }); } 通过上述代码我们实现了两次charCount的并发调用，Promise.all接受的是一个数组，它可以将数组中的promise对象并发执行； async/await的几种错误处理方式 第一种：捕捉整个async/await函数的错误 async function charCountAdd(data1, data2) { const d1=await charCount(data1); const d2=await charCount(data2); return d1+d2; } charCountAdd('Hello','Hi') .then(console.log) .catch(console.log);//捕捉整个async/await函数的错误 ... 这种方式可以捕捉整个charCountAdd运行过程中出现的错误，错误可能是由charCountAdd本身产生的，也可能是由对data1的计算中或data2的计算中产生的。 第二种：捕捉单个的await表达式的错误 async function charCountAdd(data1, data2) { const d1=await charCount(data1) .catch(e=&gt;console.log('d1 is null')); const d2=await charCount(data2) .catch(e=&gt;console.log('d2 is null')); return d1+d2; } charCountAdd('Hello','Hi').then(console.log); 通过这种方式可以捕捉每一个await表达式的错误，如果既要捕捉每一个await表达式的错误，又要捕捉整个charCountAdd函数的错误，可以在调用charCountAdd的时候加个catch。 ... charCountAdd('Hello','Hi') .then(console.log) .catch(console.log);//捕捉整个async/await函数的错误 ... 第三种：同时捕捉多个的await表达式的错误 async function charCountAdd(data1, data2) { let d1,d2; try { d1=await charCount(data1); d2=await charCount(data2); }catch (e){ console.log('d1 is null'); } return d1+d2; } charCountAdd('Hello','Hi') .then(console.log); function charCount(data) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(data.length); }, 1000); }); } 2.Object.values() Object.values()是一个与Object.keys()类似的新函数，但返回的是Object自身属性的所有值，不包括继承的值。 假设我们要遍历如下对象obj的所有值： const obj = {a: 1, b: 2, c: 3}; 不使用Object.values() :ES7 const vals=Object.keys(obj).map(key=&gt;obj[key]); console.log(vals);//[1, 2, 3] 使用Object.values() :ES8 const values=Object.values(obj1); console.log(values);//[1, 2, 3] 从上述代码中可以看出Object.values()为我们省去了遍历key，并根据这些key获取value的步骤。 3.Object.entries Object.entries()函数返回一个给定对象自身可枚举属性的键值对的数组。 接下来我们来遍历上文中的obj对象的所有属性的key和value： 不使用Object.entries() :ES7 Object.keys(obj).forEach(key=&gt;{ console.log('key:'+key+' value:'+obj[key]); }) //key:a value:1 //key:b value:2 //key:c value:3 使用Object.entries() :ES8 for(let [key,value] of Object.entries(obj1)){ console.log(`key: ${key} value:${value}`) } //key:a value:1 //key:b value:2 //key:c value:3 4.String padding 在ES8中String新增了两个实例函数String.prototype.padStart和String.prototype.padEnd，允许将空字符串或其他字符串添加到原始字符串的开头或结尾。 String.padStart(targetLength,[padString]) targetLength:当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。 padString:(可选)填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断，此参数的缺省值为 &quot; &quot;。 console.log('0.0'.padStart(4,'10')) //10.0 console.log('0.0'.padStart(20))// 0.00 String.padEnd(targetLength,padString]) targetLength:当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。 padString:(可选) 填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断，此参数的缺省值为 &quot; &quot;； console.log('0.0'.padEnd(4,'0')) //0.00 console.log('0.0'.padEnd(10,'0'))//0.00000000 4.函数参数列表结尾允许逗号 这是一个不痛不痒的更新，主要作用是方便使用git进行多人协作开发时修改同一个函数减少不必要的行变更。 不使用ES8 //程序员A var f = function(a, b ) { ... } //程序员B var f = function(a, b, //变更行 c //变更行 ) { ... } //程序员C var f = function(a, b, c, //变更行 d //变更行 ) { ... } 使用ES8 //程序员A var f = function(a, b, ) { ... } //程序员B var f = function(a, b, c, //变更行 ) { ... } //程序员C var f = function(a, b, c, d, //变更行 ) { ... } 5.Object.getOwnPropertyDescriptors() 6. Object.getOwnPropertyDescriptors()函数用来获取一个对象的所有自身属性的描述符,如果没有任何自身属性，则返回空对象。 函数原型： Object.getOwnPropertyDescriptors(obj) 复制代码返回obj对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象。 const obj2 = { name: 'Jine', get age() { return '18' } }; Object.getOwnPropertyDescriptors(obj2) // { // age: { // configurable: true, // enumerable: true, // get: function age(){}, //the getter function // set: undefined // }, // name: { // configurable: true, // enumerable: true, // value:&quot;Jine&quot;, // writable:true // } // } 参照阮一峰博客：http://es6.ruanyifeng.com/#README es6常见题：https://blog.csdn.net/qq_39207948/article/details/80678800 数组用法：https://blog.csdn.net/tang15886395749/article/details/65629898 来源链接：https://juejin.im/post/5b9cb3336fb9a05d290ee47e ","link":"https://lingtin.github.io/post/hQGSf1dCT/"},{"title":"VsCode扩展插件同步","content":"⭐️ VsCode扩展插件同步 🔥🔥VsCode扩展插件同步 1、在vscode扩展市场 搜索 &quot;Settings Sync&quot; 并安装 2、登录设置GitHub token令牌 （1）、创建Token 进入github 点击头像，点击Settings ，点击左侧 Developer settings， 选择 Personal access tokens， 点击Generate New Token。 （2）、填写名称和一些参数 设置token名称，勾选gist 点击创建token。 （3）、保存token值（ 这个token只会显示一次，以后会经常用到） 3、设置vscode (1)、打开vscode命令 输入sync 会有几个选项，这里直接选择sync update 这个选项 (2)、使用刚刚 保存下来token 直接复制进去 syn setting就设置完了，你可以下载一些插件，同步一下，然后使用同样的token设置，这样子就可以同步了。 4、在别的电脑设备同步插件 同样安装sync setting 这个插件，使用vscode命令下 sync download setting， 会让你填写之前的token信息。 在自己的token找不到情况下 ,可以在自己原设备的 sync update setting 更新的时候观察下控制台，也会打印出你的token信息 ","link":"https://lingtin.github.io/post/-vsextendsync/"},{"title":"H5 双端库集合（一）","content":"👍👍 jq,zp库集合 👍👍 库集合 Mocha ### https://tgideas.qq.com/intro.html Mocha是TGideas官方设计团队，根据目前移动端官网、微官网、运营活动页面上经常出现的元素进行提取，量身打造的移动端页面UI样式库。统一的模块代码风格及公用CSS库，可以编码效率，帮助日常的移动端页面快速生成。 【dome】 http://tgideas.github.io/mocha/demo/ 【文档】 http://tgideas.github.io/mocha/docs/ 【github】 https://github.com/tgideas/mocha/ TGideas Milo库使用说明 https://tgideas.qq.com/intro.html 使用场景：PC和移动端 milo 是一款前端JS库，包含了双端登录、弹出层、TAB切换等常用组件。 官网链接： https://tgideas.qq.com/doc/ MAC全栈开发环境搭建指南 MAC全栈开发环境搭建指南 是由 凹凸实验室 整理的，面向互联网全栈职业的MAC开发环境搭建指引手册。它几乎涵盖了使用MAC进行互联网工作的方方面面，包含但不限于通用环境配置、交互及设计、前端开发、后台开发、测试以及部署等各个工作角色、流程步骤所需要的各种软件安装配置指引，奇淫技巧。而目的只有一个：带你用MAC带你装逼带你飞！ 官网链接：https://mac.aotu.io/docs/ CreateJS CreateJS是基于HTML5开发的一套模块化的库和工具。 基于这些库，可以非常快捷地开发出基于HTML5的游戏、动画和交互应用。 官网链接：http://www.createjs.cc/ ELF HTML5 构建工具 ELF 是凹凸实验室出品的一套面向开发者的灵活可扩展的 HTML5 构建工具， 可用来制作各种 HTML5 场景营销活动页面； 它基于 Webpack 进行自动化构建，提供基础功能组件和初始化示例模板； 利用 ELF 提供的命令行工具 elf-cli，开发者可自由通过模板和组件的组合来快速定制开发 HTML5 场景应用。 官网链接：https://elf.aotu.io/ FrozenUI FrozenUI 是一套基于移动端的 UI 库。它非常轻量、精美，遵从手机 QQ 设计规范，提供了表单、对话框、列表等常用组件。此外，FrozenUI 还提供文字截断、1px边框、rem、两端留白等常用场景的解决方案。CSS 做得更模块化和颗粒化，使用 sass 编写 CSS 代码，你完全可以按照实际情况按需加载。 官网链接： http://frozenui.github.io/ GitHub：https://github.com/frozenui/frozenui iSparta iSparta是 PNG 压缩与格式转换工具。提供 PNG 等图片格式的图片压缩，PNG 等格式向 APNG 、WebP 格式的转换，APNG 动图向动态 WebP 格式的转换。 官网链接：http://isparta.github.io/index.html GitHub：https://github.com/iSparta/iSparta ","link":"https://lingtin.github.io/post/EBzxgKBAR/"},{"title":"使用vscode发布插件","content":"😵 使用vscode发布插件 😵😵 使用vscode发布插件 当然默认了是安装nodejs跟vscode，这里我略过。 1/有一个微软的账号 2/登录code市场,创造一个团队 3/创建一个 Personal Access token 4/全局安装vsce模块 5/github 新建一个对应的仓库 6/创建项目 package.json版本的书写 7/code snippets 对应的json 文件 8/对应的静态文件等(vsix) 9/发布发布包publish 第一步：创建 微软账号 微软code登陆链接：https://marketplace.visualstudio.com/ 注册完账号后，打开自己的个人中心 第二步：创建一个团队 1、选择发布创建! 第三步：创建一个Personal Access token令牌 注意注意: token 令牌要保留, 发布的时候需要用到。 第四步：全局安装 vsce cmd窗口 使用命令 npm install -g vsce vsce --help vsce Options: -V, --version output the version number -h, --help output usage information Commands: ls [options] 列出实际会发布的文件列表 package [options] 打包成一个插件 publish [options] [&lt;version&gt;] 发布插件 unpublish [options] [&lt;extensionid&gt;] 插件下架 list &lt;publisher&gt; 列出某个发布者下所有发布的,需要配置好token 额,不然会提示输入 ls-publishers 列出所有已知的发布者 create-publisher &lt;publisher&gt; 创建一个新的发布者 delete-publisher &lt;publisher&gt; 删除一个发布者 login &lt;publisher&gt; 登录一个发布者到发布者列表中 logout &lt;publisher&gt; 反之,退出发布者 第五步：在github上新建一个仓库 这个就不多说了 github传送门地址 https://github.com/ 第六步：项目创建 /package.json版本的书写 项目创建 vscode 团队，为插件开发提供了一个工具。 先全局安装这个，然后执行 yo code 来开始我们的工作。 npm install -g yo generator-code 在完成上面的安装后，可以通过执行命令 yo code yo code 通过执行上面的命令后 得到如下 输入提示选择 （1）创建哪种类型的扩展? （2）扩展的名称 （3）扩展项目的名称（项目创建的文件名称用这个） （4）对这个扩展的描述 （5）是否启用类型检查 （6）是问你要不要创建一个git仓库用于版本管理 （7）使用哪个包管理器（npm &amp; yarn ） （5）以后要发布用到的一名称（和以后再发布时候有一个名字是对应上的） 这几个描述都会在package.json 这个文件里面有对应的属性来表示。 { &quot;name&quot;: &quot;aa&quot;, //插件扩展名称（对应创建项目时候的输入） &quot;displayName&quot;: &quot;&quot;, &quot;description&quot;: &quot;&quot;, //插件扩展的描述（对应创建项目时候的输入） &quot;version&quot;: &quot;0.0.1&quot;, &quot;publisher&quot;: &quot;&quot;, //发布时候的一个名称（对应创建项目时候的输入） &quot;engines&quot;: { &quot;vscode&quot;: &quot;^0.10.10&quot; }, &quot;categories&quot;: [ &quot;Other&quot; ], &quot;activationEvents&quot;: [ //这是我们要理解的地方，是触发插件执行一些代码的配置 &quot;onCommand:extension.sayHello&quot; //这种是通过输入命令来触发执行的 ], &quot;main&quot;: &quot;./out/src/extension&quot;, //这个是配置TypeScript编译成js的输出目录 &quot;contributes&quot;: { &quot;commands&quot;: [{ //title 和 command是一个对应关系的 &quot;command&quot;: &quot;extension.sayHello&quot;, //这个是对应上面那个命令触发的，在代码里面也要用到 &quot;title&quot;: &quot;Hello World&quot; //这个是我们在vscode里面输入的命令 }] }, &quot;scripts&quot;: { //是在发布打包，或者其他运行时候，要执行的一些脚本命令 &quot;vscode:prepublish&quot;: &quot;node ./node_modules/vscode/bin/compile&quot;, &quot;compile&quot;: &quot;node ./node_modules/vscode/bin/compile -watch -p ./&quot;, &quot;postinstall&quot;: &quot;node ./node_modules/vscode/bin/install&quot; }, &quot;devDependencies&quot;: { //这是开发的依赖包，如果有其他的依赖包，并要打包的话，需要把dev去掉 &quot;typescript&quot;: &quot;^3.3.1&quot;, &quot;vscode&quot;: &quot;^1.1.28&quot;, &quot;eslint&quot;: &quot;^5.13.0&quot;, &quot;@types/node&quot;: &quot;^10.12.21&quot;, &quot;@types/mocha&quot;: &quot;^2.2.42&quot; } } 介绍完package.json后，我可以来看看目录。 我们可以来运行一下看看效果如果。我们打开一个vscode并把我们的目录自己拖拉到vscode的界面上，然后选择调试窗口，并点击开始调试 8、对应的静态文件等(vsix) 本地打包对应的vsix ，使用之前安装的vsce执行如下命令： vsce package 9、发布发布包publish 使用vsce以下命令创建新的发布者 vsce create-publisher your-publisher-name your-publisher-name必须是字母数字下划线，这是全网唯一的账号，然后会依次要求输入昵称、邮箱、令牌： 创建成功后会默认登录这个账号，接下来你可以直接发布了 发布vsix，使用命令 vsce publish ","link":"https://lingtin.github.io/post/MkNncIB5J/"},{"title":"Linux下使用nvm安装node方法","content":"😊 node nvm安装方法 😊😊 nvm 安装方法 第一种安装方法： 安装nodejs ： sudo apt-get install nodejs 运行 nodejs -v 会弹出安装node的版本号 这里使用的是 nodejs 并不是常用的node ，可以通过 sudo ln -s /usr/bin/nodejs /usr/bin/node 命令让node与nodejs 建立软连接，接着就可以使用 node命令 安装npm: sudo apt-get install npm 测试安装是否成功: npm -v 弹出安装的版本号，即可证明安装成功 第二种安装方法： 先安装，nvm，即是Node Version Manager(Node版本管理器) curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash 或者使用 wget wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash 之后需要激活nvm: $ source ~/.nvm/nvm.sh 激活完成后，安装node nvm install node 安装完成后，切换到该版本 nvm use node 要安装特定版本的节点： nvm install 6.14.4 ＃或10.10.0,8.9.1等 安装的第一个版本成为默认版本。新shell将以节点的默认版本（例如，nvm alias default）开始。 可以使用ls-remote列出可用版本： nvm ls-remote 然后在任何新的shell中只使用已安装的版本： nvm使用节点 或者你可以运行它： nvm run node --version 或者，您可以使用所需的节点版本在子shell中运行任意命令： nvm exec 4.2 node --version 具体详情请看github地址 https://github.com/nvm-sh/nvm 总结： 个人比较喜欢第二种方式，第二种方式会安装最新的版本，而且可以可以通过nvm可以任意切换node的版本 ","link":"https://lingtin.github.io/post/zKyKiHlvG/"},{"title":"Contos安装yum","content":"🍺🍺 (^−)☆ Contos安装yum 🍕🍕 (^−)☆ Contos安装yum 1、删除现有Python [root@test ~]# rpm -qa|grep python|xargs rpm -ev --allmatches --nodeps ##强制删除已安装程序及其关联 [root@test ~]# whereis python |xargs rm -frv ##删除所有残余文件 ##xargs，允许你对输出执行其他某些命令 [root@test ~]# whereis python ##验证删除，返回无结果 2、删除现有的yum [root@test ~]# rpm -qa|grep yum|xargs rpm -ev --allmatches --nodeps [root@test ~]# whereis yum |xargs rm -frv 3、从http://mirrors.ustc.edu.cn/centos/6.4/os/x86_64/Packages/下载相应的包 python-2.6.6-36.el6.x86_64.rpm python-devel-2.6.6-36.el6.x86_64.rpm python-libs-2.6.6-36.el6.x86_64.rpm python-pycurl-7.19.0-8.el6.x86_64.rpm python-setuptools-0.6.10-3.el6.noarch.rpm python-urlgrabber-3.9.1-8.el6.noarch.rpm python-iniparse-0.3.1-2.1.el6.noarch.rpm rpm-python-4.8.0-32.el6.x86_64.rpm yum-3.2.29-40.el6.centos.noarch.rpm yum-metadata-parser-1.1.2-16.el6.x86_64.rpm yum-utils-1.1.30-14.el6.noarch.rpm yum-plugin-fastestmirror-1.1.30-14.el6.noarch.rpm yum-plugin-protectbase-1.1.30-14.el6.noarch.rpm yum-plugin-aliases-1.1.30-14.el6.noarch.rpm yum-plugin-downloadonly-1.1.30-14.el6.noarch.rpm 由于源中版本会更新，具体请查看URL中的版本再下载下来！ [root@test ~]# rpm -Uvh --replacepkgs python*.rpm [root@test ~]# rpm -Uvh --replacepkgs rpm-python*.rpm yum*.rpm 可能之间还需要zlib和zlib-devel包，根据情况下载并安装！ 工作中，搭建Linux测试环境少不了安装一系列软件；为了实现简易安装软件，必须先装好yum。 【安装环境】 物理机操作系统：Win7x64 虚拟机：VMware Workstation 版本10.0.3 Linux镜像：CentOS-7-x86_64-DVD-1611.iso 安装CentOS-7教程：http://www.centoscn.com/image-text/setup/2014/0723/3341.html 【安装步骤】（修改版20170324） 1.检查是否安装yum包 查看是否安装了yum，若是安装了，那么又有哪些yum包： [root@localhost~]# rpm -qa |grep yum 2.删除原有的yum [root@localhost~]#rpm -aq|grep yum|xargs rpm -e –nodeps 3.进入专门存放下载文件的路径 [root@localhost~]# cd /usr/local/src 4.下载安装依赖包python python-iniparse 下载地址http://mirrors.163.com/centos/7/os/x86_64/Packages/ （进度条显示100%表示已下载完） [root@localhost src]# wget http://mirrors.163.com/centos/7/os/x86_64/Packages/python-2.7.5-48.el7.x86_64.rpm [root@localhost src]#wget http://mirrors.163.com/centos/7/os/x86_64/Packages/python-iniparse-0.4-9.el7.noarch.rpm 5.安装依赖包 #rpm –ivh python-2.7.5-48.el7.x86_64.rpm python-iniparse-0.4-9.el7.noarch.rpm 6.下载yum安装文件 #wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-3.4.3-150.el7.centos.noarch.rpm #wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-metadata-parser-1.1.4-10.el7.x86_64.rpm #wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-plugin-fastestmirror-1.1.31-40.el7.noarch.rpm #wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-updateonboot-1.1.31-40.el7.noarch.rpm #wget http://mirrors.163.com/centos/7/os/x86_64/Packages/yum-utils-1.1.31-40.el7.noarch.rpm 7.安装yum 理论上运行： rpm -ivh yum-* --nodeps --force （实际上，因为目录下有几个其他版本的yum文件，所以是直接罗列出要安装的那几个，运行命令： #rpm -ivh yum-3.4.3-150.el7.centos.noarch.rpm yum-metadata-parser-1.1.4-10.el7.x86_64.rpm yum-plugin-fastestmirror-1.1.31-40.el7.noarch.rpm yum-updateonboot-1.1.31-40.el7.noarch.rpm yum-utils-1.1.31-40.el7.noarch.rpm --nodeps --force --nodeps：不验证包依赖 --force：--replacepkgs--replacefiles的缩写 --replacefiles：忽略软件包之间的冲突的文件 --replacepkgs：如果软件包已经有了，重新安装软件包 8.更改yum源CentOS-Base.repo 备份原文件 mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 下载配置文件 wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 编辑配置文件 （所有$releasever替换成7（因为centos版本为7）；） [root@localhost ~]# cd /etc/yum.repos.d [root@localhost yum.repos.d]# sed -i 's/$releasever/7/g' CentOS-Base.repo 9.显示已配置的源 [root@localhost ~]# yum repolist 更新本地软件库列表 10.生成yum缓存 [root@localhost ~]# yum clean all [root@localhost ~]# yum makecache 11.测试 #yum list python 显示出python安装包信息，则yum安装成功。 Note：有时候运行yum命令会报错，复制黏贴运行多一次即可。 yum安装安装epel扩展源 yum安装python-pip 安装日志 -----【2018/3/11：安装成功】----- 之前总结的失败原因不对，正确的原因是：①安装包的版本下载错；②安装包没下载够；③vi文件没全部正确替换。主要做了如下更正： （1）增加下载和安装两个yum文件yum-updateonboot-1.1.31-40.el7.noarch.rpm和yum-utils-1.1.31-40.el7.noarch.rpm； （2） vi文件CentOS-Base.repo时，所有$releasever替换成7（因为centos版本为7）； （3）所有如name=CentOS-$releasever - Base - 163.com，后面的- 163.com去掉； （4）所有$basearch替换成x86_64； （5）所有gpgcheck=1替换成gpgcheck=0； （6）末尾enabled=0替换成enabled=1 -----【2017/3/24：真正安装成功】----- 用yum安装软件的时候报错“ Cannot find a valid baseurl for repo: extras/x86_64 &quot; 原来上次安装yum成功是一个假象。总结原因：①yum源的url失效；②yum源没在线更新。主要做了如下更正： （1）把yum源更换为阿里云源http://mirrors.aliyun.com/repo/； （2）运行yum repolist触发yum库在线更新 【扩展】后续用yum命令安装软件前，建议先更新软件库 sudo yum update ","link":"https://lingtin.github.io/post/UQtqEHM7_/"},{"title":"Mongodb远程连接","content":"👏 Mongodb远程连接 ！ ✍️ 连接到自定义的用户... ... 1.修改配置文件mongodb.conf 命令：vim /etc/mongodb.conf 把 bindip=127.0.0.1 这一行注释掉 或者是修改成 bindip=0.0.0.0 2.重启mongodb服务 命令：systemctl restart mongod.service 2.1防火墙开放27017端口 命令：iptables -A INPUT -p tcp -m state --state NEW -m tcp --dport 27017 -j ACCEPT 3.远程连接 要连接的IP：xxx.xxx.xxx.xx 命令：mongo xxx.xxx.xxx.xx:27017 这样就可以连接到xxx.xxx.xxx.xx(你的ip)的mongodb/的数据库 连接到自定义的用户×× 1.增加 use admin switched to db admin db.addUser('username','password') 2.远程连接 命令： mongo xxx.xxx.xxx.xx:27017/admin -uusername -p 输入password即可 ","link":"https://lingtin.github.io/post/DCC1RrEDv/"}]}